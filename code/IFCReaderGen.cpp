/*
Open Asset Import Library (ASSIMP)
----------------------------------------------------------------------

Copyright (c) 2006-2010, ASSIMP Development Team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the ASSIMP team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the ASSIMP Development Team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** MACHINE-GENERATED by scripts/ICFImporter/CppGenerator.py */


#ifndef ASSIMP_BUILD_NO_IFC_IMPORTER

#include "IFCReaderGen.h"

namespace Assimp {
using namespace IFC;

namespace {

    typedef EXPRESS::ConversionSchema::SchemaEntry SchemaEntry;
    const SchemaEntry schema_raw[] =  {
        SchemaEntry("ifcabsorbeddosemeasure",NULL )
,       SchemaEntry("ifcaccelerationmeasure",NULL )
,       SchemaEntry("ifcamountofsubstancemeasure",NULL )
,       SchemaEntry("ifcangularvelocitymeasure",NULL )
,       SchemaEntry("ifcareameasure",NULL )
,       SchemaEntry("ifcboolean",NULL )
,       SchemaEntry("ifcboxalignment",NULL )
,       SchemaEntry("ifccomplexnumber",NULL )
,       SchemaEntry("ifccompoundplaneanglemeasure",NULL )
,       SchemaEntry("ifccontextdependentmeasure",NULL )
,       SchemaEntry("ifccountmeasure",NULL )
,       SchemaEntry("ifccurvaturemeasure",NULL )
,       SchemaEntry("ifcdayinmonthnumber",NULL )
,       SchemaEntry("ifcdaylightsavinghour",NULL )
,       SchemaEntry("ifcdescriptivemeasure",NULL )
,       SchemaEntry("ifcdimensioncount",NULL )
,       SchemaEntry("ifcdoseequivalentmeasure",NULL )
,       SchemaEntry("ifcdynamicviscositymeasure",NULL )
,       SchemaEntry("ifcelectriccapacitancemeasure",NULL )
,       SchemaEntry("ifcelectricchargemeasure",NULL )
,       SchemaEntry("ifcelectricconductancemeasure",NULL )
,       SchemaEntry("ifcelectriccurrentmeasure",NULL )
,       SchemaEntry("ifcelectricresistancemeasure",NULL )
,       SchemaEntry("ifcelectricvoltagemeasure",NULL )
,       SchemaEntry("ifcenergymeasure",NULL )
,       SchemaEntry("ifcfontstyle",NULL )
,       SchemaEntry("ifcfontvariant",NULL )
,       SchemaEntry("ifcfontweight",NULL )
,       SchemaEntry("ifcforcemeasure",NULL )
,       SchemaEntry("ifcfrequencymeasure",NULL )
,       SchemaEntry("ifcgloballyuniqueid",NULL )
,       SchemaEntry("ifcheatfluxdensitymeasure",NULL )
,       SchemaEntry("ifcheatingvaluemeasure",NULL )
,       SchemaEntry("ifchourinday",NULL )
,       SchemaEntry("ifcidentifier",NULL )
,       SchemaEntry("ifcilluminancemeasure",NULL )
,       SchemaEntry("ifcinductancemeasure",NULL )
,       SchemaEntry("ifcinteger",NULL )
,       SchemaEntry("ifcintegercountratemeasure",NULL )
,       SchemaEntry("ifcionconcentrationmeasure",NULL )
,       SchemaEntry("ifcisothermalmoisturecapacitymeasure",NULL )
,       SchemaEntry("ifckinematicviscositymeasure",NULL )
,       SchemaEntry("ifclabel",NULL )
,       SchemaEntry("ifclengthmeasure",NULL )
,       SchemaEntry("ifclinearforcemeasure",NULL )
,       SchemaEntry("ifclinearmomentmeasure",NULL )
,       SchemaEntry("ifclinearstiffnessmeasure",NULL )
,       SchemaEntry("ifclinearvelocitymeasure",NULL )
,       SchemaEntry("ifclogical",NULL )
,       SchemaEntry("ifcluminousfluxmeasure",NULL )
,       SchemaEntry("ifcluminousintensitydistributionmeasure",NULL )
,       SchemaEntry("ifcluminousintensitymeasure",NULL )
,       SchemaEntry("ifcmagneticfluxdensitymeasure",NULL )
,       SchemaEntry("ifcmagneticfluxmeasure",NULL )
,       SchemaEntry("ifcmassdensitymeasure",NULL )
,       SchemaEntry("ifcmassflowratemeasure",NULL )
,       SchemaEntry("ifcmassmeasure",NULL )
,       SchemaEntry("ifcmassperlengthmeasure",NULL )
,       SchemaEntry("ifcminuteinhour",NULL )
,       SchemaEntry("ifcmodulusofelasticitymeasure",NULL )
,       SchemaEntry("ifcmodulusoflinearsubgradereactionmeasure",NULL )
,       SchemaEntry("ifcmodulusofrotationalsubgradereactionmeasure",NULL )
,       SchemaEntry("ifcmodulusofsubgradereactionmeasure",NULL )
,       SchemaEntry("ifcmoisturediffusivitymeasure",NULL )
,       SchemaEntry("ifcmolecularweightmeasure",NULL )
,       SchemaEntry("ifcmomentofinertiameasure",NULL )
,       SchemaEntry("ifcmonetarymeasure",NULL )
,       SchemaEntry("ifcmonthinyearnumber",NULL )
,       SchemaEntry("ifcnormalisedratiomeasure",NULL )
,       SchemaEntry("ifcnumericmeasure",NULL )
,       SchemaEntry("ifcphmeasure",NULL )
,       SchemaEntry("ifcparametervalue",NULL )
,       SchemaEntry("ifcplanarforcemeasure",NULL )
,       SchemaEntry("ifcplaneanglemeasure",NULL )
,       SchemaEntry("ifcpositivelengthmeasure",NULL )
,       SchemaEntry("ifcpositiveplaneanglemeasure",NULL )
,       SchemaEntry("ifcpositiveratiomeasure",NULL )
,       SchemaEntry("ifcpowermeasure",NULL )
,       SchemaEntry("ifcpresentabletext",NULL )
,       SchemaEntry("ifcpressuremeasure",NULL )
,       SchemaEntry("ifcradioactivitymeasure",NULL )
,       SchemaEntry("ifcratiomeasure",NULL )
,       SchemaEntry("ifcreal",NULL )
,       SchemaEntry("ifcrotationalfrequencymeasure",NULL )
,       SchemaEntry("ifcrotationalmassmeasure",NULL )
,       SchemaEntry("ifcrotationalstiffnessmeasure",NULL )
,       SchemaEntry("ifcsecondinminute",NULL )
,       SchemaEntry("ifcsectionmodulusmeasure",NULL )
,       SchemaEntry("ifcsectionalareaintegralmeasure",NULL )
,       SchemaEntry("ifcshearmodulusmeasure",NULL )
,       SchemaEntry("ifcsolidanglemeasure",NULL )
,       SchemaEntry("ifcsoundpowermeasure",NULL )
,       SchemaEntry("ifcsoundpressuremeasure",NULL )
,       SchemaEntry("ifcspecificheatcapacitymeasure",NULL )
,       SchemaEntry("ifcspecularexponent",NULL )
,       SchemaEntry("ifcspecularroughness",NULL )
,       SchemaEntry("ifctemperaturegradientmeasure",NULL )
,       SchemaEntry("ifctext",NULL )
,       SchemaEntry("ifctextalignment",NULL )
,       SchemaEntry("ifctextdecoration",NULL )
,       SchemaEntry("ifctextfontname",NULL )
,       SchemaEntry("ifctexttransformation",NULL )
,       SchemaEntry("ifcthermaladmittancemeasure",NULL )
,       SchemaEntry("ifcthermalconductivitymeasure",NULL )
,       SchemaEntry("ifcthermalexpansioncoefficientmeasure",NULL )
,       SchemaEntry("ifcthermalresistancemeasure",NULL )
,       SchemaEntry("ifcthermaltransmittancemeasure",NULL )
,       SchemaEntry("ifcthermodynamictemperaturemeasure",NULL )
,       SchemaEntry("ifctimemeasure",NULL )
,       SchemaEntry("ifctimestamp",NULL )
,       SchemaEntry("ifctorquemeasure",NULL )
,       SchemaEntry("ifcvaporpermeabilitymeasure",NULL )
,       SchemaEntry("ifcvolumemeasure",NULL )
,       SchemaEntry("ifcvolumetricflowratemeasure",NULL )
,       SchemaEntry("ifcwarpingconstantmeasure",NULL )
,       SchemaEntry("ifcwarpingmomentmeasure",NULL )
,       SchemaEntry("ifcyearnumber",NULL )
,       SchemaEntry("ifcactionsourcetypeenum",NULL )
,       SchemaEntry("ifcactiontypeenum",NULL )
,       SchemaEntry("ifcactuatortypeenum",NULL )
,       SchemaEntry("ifcaddresstypeenum",NULL )
,       SchemaEntry("ifcaheadorbehind",NULL )
,       SchemaEntry("ifcairterminalboxtypeenum",NULL )
,       SchemaEntry("ifcairterminaltypeenum",NULL )
,       SchemaEntry("ifcairtoairheatrecoverytypeenum",NULL )
,       SchemaEntry("ifcalarmtypeenum",NULL )
,       SchemaEntry("ifcanalysismodeltypeenum",NULL )
,       SchemaEntry("ifcanalysistheorytypeenum",NULL )
,       SchemaEntry("ifcarithmeticoperatorenum",NULL )
,       SchemaEntry("ifcassemblyplaceenum",NULL )
,       SchemaEntry("ifcbsplinecurveform",NULL )
,       SchemaEntry("ifcbeamtypeenum",NULL )
,       SchemaEntry("ifcbenchmarkenum",NULL )
,       SchemaEntry("ifcboilertypeenum",NULL )
,       SchemaEntry("ifcbooleanoperator",NULL )
,       SchemaEntry("ifcbuildingelementproxytypeenum",NULL )
,       SchemaEntry("ifccablecarrierfittingtypeenum",NULL )
,       SchemaEntry("ifccablecarriersegmenttypeenum",NULL )
,       SchemaEntry("ifccablesegmenttypeenum",NULL )
,       SchemaEntry("ifcchangeactionenum",NULL )
,       SchemaEntry("ifcchillertypeenum",NULL )
,       SchemaEntry("ifccoiltypeenum",NULL )
,       SchemaEntry("ifccolumntypeenum",NULL )
,       SchemaEntry("ifccompressortypeenum",NULL )
,       SchemaEntry("ifccondensertypeenum",NULL )
,       SchemaEntry("ifcconnectiontypeenum",NULL )
,       SchemaEntry("ifcconstraintenum",NULL )
,       SchemaEntry("ifccontrollertypeenum",NULL )
,       SchemaEntry("ifccooledbeamtypeenum",NULL )
,       SchemaEntry("ifccoolingtowertypeenum",NULL )
,       SchemaEntry("ifccostscheduletypeenum",NULL )
,       SchemaEntry("ifccoveringtypeenum",NULL )
,       SchemaEntry("ifccurrencyenum",NULL )
,       SchemaEntry("ifccurtainwalltypeenum",NULL )
,       SchemaEntry("ifcdampertypeenum",NULL )
,       SchemaEntry("ifcdataoriginenum",NULL )
,       SchemaEntry("ifcderivedunitenum",NULL )
,       SchemaEntry("ifcdimensionextentusage",NULL )
,       SchemaEntry("ifcdirectionsenseenum",NULL )
,       SchemaEntry("ifcdistributionchamberelementtypeenum",NULL )
,       SchemaEntry("ifcdocumentconfidentialityenum",NULL )
,       SchemaEntry("ifcdocumentstatusenum",NULL )
,       SchemaEntry("ifcdoorpaneloperationenum",NULL )
,       SchemaEntry("ifcdoorpanelpositionenum",NULL )
,       SchemaEntry("ifcdoorstyleconstructionenum",NULL )
,       SchemaEntry("ifcdoorstyleoperationenum",NULL )
,       SchemaEntry("ifcductfittingtypeenum",NULL )
,       SchemaEntry("ifcductsegmenttypeenum",NULL )
,       SchemaEntry("ifcductsilencertypeenum",NULL )
,       SchemaEntry("ifcelectricappliancetypeenum",NULL )
,       SchemaEntry("ifcelectriccurrentenum",NULL )
,       SchemaEntry("ifcelectricdistributionpointfunctionenum",NULL )
,       SchemaEntry("ifcelectricflowstoragedevicetypeenum",NULL )
,       SchemaEntry("ifcelectricgeneratortypeenum",NULL )
,       SchemaEntry("ifcelectricheatertypeenum",NULL )
,       SchemaEntry("ifcelectricmotortypeenum",NULL )
,       SchemaEntry("ifcelectrictimecontroltypeenum",NULL )
,       SchemaEntry("ifcelementassemblytypeenum",NULL )
,       SchemaEntry("ifcelementcompositionenum",NULL )
,       SchemaEntry("ifcenergysequenceenum",NULL )
,       SchemaEntry("ifcenvironmentalimpactcategoryenum",NULL )
,       SchemaEntry("ifcevaporativecoolertypeenum",NULL )
,       SchemaEntry("ifcevaporatortypeenum",NULL )
,       SchemaEntry("ifcfantypeenum",NULL )
,       SchemaEntry("ifcfiltertypeenum",NULL )
,       SchemaEntry("ifcfiresuppressionterminaltypeenum",NULL )
,       SchemaEntry("ifcflowdirectionenum",NULL )
,       SchemaEntry("ifcflowinstrumenttypeenum",NULL )
,       SchemaEntry("ifcflowmetertypeenum",NULL )
,       SchemaEntry("ifcfootingtypeenum",NULL )
,       SchemaEntry("ifcgasterminaltypeenum",NULL )
,       SchemaEntry("ifcgeometricprojectionenum",NULL )
,       SchemaEntry("ifcglobalorlocalenum",NULL )
,       SchemaEntry("ifcheatexchangertypeenum",NULL )
,       SchemaEntry("ifchumidifiertypeenum",NULL )
,       SchemaEntry("ifcinternalorexternalenum",NULL )
,       SchemaEntry("ifcinventorytypeenum",NULL )
,       SchemaEntry("ifcjunctionboxtypeenum",NULL )
,       SchemaEntry("ifclamptypeenum",NULL )
,       SchemaEntry("ifclayersetdirectionenum",NULL )
,       SchemaEntry("ifclightdistributioncurveenum",NULL )
,       SchemaEntry("ifclightemissionsourceenum",NULL )
,       SchemaEntry("ifclightfixturetypeenum",NULL )
,       SchemaEntry("ifcloadgrouptypeenum",NULL )
,       SchemaEntry("ifclogicaloperatorenum",NULL )
,       SchemaEntry("ifcmembertypeenum",NULL )
,       SchemaEntry("ifcmotorconnectiontypeenum",NULL )
,       SchemaEntry("ifcnullstyle",NULL )
,       SchemaEntry("ifcobjecttypeenum",NULL )
,       SchemaEntry("ifcobjectiveenum",NULL )
,       SchemaEntry("ifcoccupanttypeenum",NULL )
,       SchemaEntry("ifcoutlettypeenum",NULL )
,       SchemaEntry("ifcpermeablecoveringoperationenum",NULL )
,       SchemaEntry("ifcphysicalorvirtualenum",NULL )
,       SchemaEntry("ifcpileconstructionenum",NULL )
,       SchemaEntry("ifcpiletypeenum",NULL )
,       SchemaEntry("ifcpipefittingtypeenum",NULL )
,       SchemaEntry("ifcpipesegmenttypeenum",NULL )
,       SchemaEntry("ifcplatetypeenum",NULL )
,       SchemaEntry("ifcproceduretypeenum",NULL )
,       SchemaEntry("ifcprofiletypeenum",NULL )
,       SchemaEntry("ifcprojectorderrecordtypeenum",NULL )
,       SchemaEntry("ifcprojectordertypeenum",NULL )
,       SchemaEntry("ifcprojectedortruelengthenum",NULL )
,       SchemaEntry("ifcpropertysourceenum",NULL )
,       SchemaEntry("ifcprotectivedevicetypeenum",NULL )
,       SchemaEntry("ifcpumptypeenum",NULL )
,       SchemaEntry("ifcrailingtypeenum",NULL )
,       SchemaEntry("ifcrampflighttypeenum",NULL )
,       SchemaEntry("ifcramptypeenum",NULL )
,       SchemaEntry("ifcreflectancemethodenum",NULL )
,       SchemaEntry("ifcreinforcingbarroleenum",NULL )
,       SchemaEntry("ifcreinforcingbarsurfaceenum",NULL )
,       SchemaEntry("ifcresourceconsumptionenum",NULL )
,       SchemaEntry("ifcribplatedirectionenum",NULL )
,       SchemaEntry("ifcroleenum",NULL )
,       SchemaEntry("ifcrooftypeenum",NULL )
,       SchemaEntry("ifcsiprefix",NULL )
,       SchemaEntry("ifcsiunitname",NULL )
,       SchemaEntry("ifcsanitaryterminaltypeenum",NULL )
,       SchemaEntry("ifcsectiontypeenum",NULL )
,       SchemaEntry("ifcsensortypeenum",NULL )
,       SchemaEntry("ifcsequenceenum",NULL )
,       SchemaEntry("ifcservicelifefactortypeenum",NULL )
,       SchemaEntry("ifcservicelifetypeenum",NULL )
,       SchemaEntry("ifcslabtypeenum",NULL )
,       SchemaEntry("ifcsoundscaleenum",NULL )
,       SchemaEntry("ifcspaceheatertypeenum",NULL )
,       SchemaEntry("ifcspacetypeenum",NULL )
,       SchemaEntry("ifcstackterminaltypeenum",NULL )
,       SchemaEntry("ifcstairflighttypeenum",NULL )
,       SchemaEntry("ifcstairtypeenum",NULL )
,       SchemaEntry("ifcstateenum",NULL )
,       SchemaEntry("ifcstructuralcurvetypeenum",NULL )
,       SchemaEntry("ifcstructuralsurfacetypeenum",NULL )
,       SchemaEntry("ifcsurfaceside",NULL )
,       SchemaEntry("ifcsurfacetextureenum",NULL )
,       SchemaEntry("ifcswitchingdevicetypeenum",NULL )
,       SchemaEntry("ifctanktypeenum",NULL )
,       SchemaEntry("ifctendontypeenum",NULL )
,       SchemaEntry("ifctextpath",NULL )
,       SchemaEntry("ifcthermalloadsourceenum",NULL )
,       SchemaEntry("ifcthermalloadtypeenum",NULL )
,       SchemaEntry("ifctimeseriesdatatypeenum",NULL )
,       SchemaEntry("ifctimeseriesscheduletypeenum",NULL )
,       SchemaEntry("ifctransformertypeenum",NULL )
,       SchemaEntry("ifctransitioncode",NULL )
,       SchemaEntry("ifctransportelementtypeenum",NULL )
,       SchemaEntry("ifctrimmingpreference",NULL )
,       SchemaEntry("ifctubebundletypeenum",NULL )
,       SchemaEntry("ifcunitenum",NULL )
,       SchemaEntry("ifcunitaryequipmenttypeenum",NULL )
,       SchemaEntry("ifcvalvetypeenum",NULL )
,       SchemaEntry("ifcvibrationisolatortypeenum",NULL )
,       SchemaEntry("ifcwalltypeenum",NULL )
,       SchemaEntry("ifcwasteterminaltypeenum",NULL )
,       SchemaEntry("ifcwindowpaneloperationenum",NULL )
,       SchemaEntry("ifcwindowpanelpositionenum",NULL )
,       SchemaEntry("ifcwindowstyleconstructionenum",NULL )
,       SchemaEntry("ifcwindowstyleoperationenum",NULL )
,       SchemaEntry("ifcworkcontroltypeenum",NULL )
,       SchemaEntry("ifcactorselect",NULL )
,       SchemaEntry("ifcappliedvalueselect",NULL )
,       SchemaEntry("ifcaxis2placement",NULL )
,       SchemaEntry("ifcbooleanoperand",NULL )
,       SchemaEntry("ifccharacterstyleselect",NULL )
,       SchemaEntry("ifcclassificationnotationselect",NULL )
,       SchemaEntry("ifccolour",NULL )
,       SchemaEntry("ifccolourorfactor",NULL )
,       SchemaEntry("ifcconditioncriterionselect",NULL )
,       SchemaEntry("ifccsgselect",NULL )
,       SchemaEntry("ifccurvefontorscaledcurvefontselect",NULL )
,       SchemaEntry("ifccurveoredgecurve",NULL )
,       SchemaEntry("ifccurvestylefontselect",NULL )
,       SchemaEntry("ifcdatetimeselect",NULL )
,       SchemaEntry("ifcdefinedsymbolselect",NULL )
,       SchemaEntry("ifcderivedmeasurevalue",NULL )
,       SchemaEntry("ifcdocumentselect",NULL )
,       SchemaEntry("ifcdraughtingcalloutelement",NULL )
,       SchemaEntry("ifcfillareastyletileshapeselect",NULL )
,       SchemaEntry("ifcfillstyleselect",NULL )
,       SchemaEntry("ifcgeometricsetselect",NULL )
,       SchemaEntry("ifchatchlinedistanceselect",NULL )
,       SchemaEntry("ifclayereditem",NULL )
,       SchemaEntry("ifclibraryselect",NULL )
,       SchemaEntry("ifclightdistributiondatasourceselect",NULL )
,       SchemaEntry("ifcmaterialselect",NULL )
,       SchemaEntry("ifcmeasurevalue",NULL )
,       SchemaEntry("ifcmetricvalueselect",NULL )
,       SchemaEntry("ifcobjectreferenceselect",NULL )
,       SchemaEntry("ifcorientationselect",NULL )
,       SchemaEntry("ifcpointorvertexpoint",NULL )
,       SchemaEntry("ifcpresentationstyleselect",NULL )
,       SchemaEntry("ifcshell",NULL )
,       SchemaEntry("ifcsimplevalue",NULL )
,       SchemaEntry("ifcsizeselect",NULL )
,       SchemaEntry("ifcspecularhighlightselect",NULL )
,       SchemaEntry("ifcstructuralactivityassignmentselect",NULL )
,       SchemaEntry("ifcsurfaceorfacesurface",NULL )
,       SchemaEntry("ifcsurfacestyleelementselect",NULL )
,       SchemaEntry("ifcsymbolstyleselect",NULL )
,       SchemaEntry("ifctextfontselect",NULL )
,       SchemaEntry("ifctextstyleselect",NULL )
,       SchemaEntry("ifctrimmingselect",NULL )
,       SchemaEntry("ifcunit",NULL )
,       SchemaEntry("ifcvalue",NULL )
,       SchemaEntry("ifcvectorordirection",NULL )
,       SchemaEntry("ifcrepresentationitem",&STEP::ObjectHelper<IfcRepresentationItem,0>::Construct )
,       SchemaEntry("ifcgeometricrepresentationitem",&STEP::ObjectHelper<IfcGeometricRepresentationItem,0>::Construct )
,       SchemaEntry("ifccurve",&STEP::ObjectHelper<IfcCurve,0>::Construct )
,       SchemaEntry("ifcboundedcurve",&STEP::ObjectHelper<IfcBoundedCurve,0>::Construct )
,       SchemaEntry("ifccompositecurve",&STEP::ObjectHelper<IfcCompositeCurve,2>::Construct )
,       SchemaEntry("ifc2dcompositecurve",&STEP::ObjectHelper<Ifc2DCompositeCurve,0>::Construct )
,       SchemaEntry("ifcroot",&STEP::ObjectHelper<IfcRoot,4>::Construct )
,       SchemaEntry("ifcobjectdefinition",&STEP::ObjectHelper<IfcObjectDefinition,0>::Construct )
,       SchemaEntry("ifcobject",&STEP::ObjectHelper<IfcObject,1>::Construct )
,       SchemaEntry("ifccontrol",&STEP::ObjectHelper<IfcControl,0>::Construct )
,       SchemaEntry("ifcactionrequest",&STEP::ObjectHelper<IfcActionRequest,1>::Construct )
,       SchemaEntry("ifcactor",&STEP::ObjectHelper<IfcActor,1>::Construct )
,       SchemaEntry("ifcactorrole",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctypeobject",&STEP::ObjectHelper<IfcTypeObject,2>::Construct )
,       SchemaEntry("ifctypeproduct",&STEP::ObjectHelper<IfcTypeProduct,2>::Construct )
,       SchemaEntry("ifcelementtype",&STEP::ObjectHelper<IfcElementType,1>::Construct )
,       SchemaEntry("ifcdistributionelementtype",&STEP::ObjectHelper<IfcDistributionElementType,0>::Construct )
,       SchemaEntry("ifcdistributioncontrolelementtype",&STEP::ObjectHelper<IfcDistributionControlElementType,0>::Construct )
,       SchemaEntry("ifcactuatortype",&STEP::ObjectHelper<IfcActuatorType,1>::Construct )
,       SchemaEntry("ifcaddress",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdistributionflowelementtype",&STEP::ObjectHelper<IfcDistributionFlowElementType,0>::Construct )
,       SchemaEntry("ifcflowcontrollertype",&STEP::ObjectHelper<IfcFlowControllerType,0>::Construct )
,       SchemaEntry("ifcairterminalboxtype",&STEP::ObjectHelper<IfcAirTerminalBoxType,1>::Construct )
,       SchemaEntry("ifcflowterminaltype",&STEP::ObjectHelper<IfcFlowTerminalType,0>::Construct )
,       SchemaEntry("ifcairterminaltype",&STEP::ObjectHelper<IfcAirTerminalType,1>::Construct )
,       SchemaEntry("ifcenergyconversiondevicetype",&STEP::ObjectHelper<IfcEnergyConversionDeviceType,0>::Construct )
,       SchemaEntry("ifcairtoairheatrecoverytype",&STEP::ObjectHelper<IfcAirToAirHeatRecoveryType,1>::Construct )
,       SchemaEntry("ifcalarmtype",&STEP::ObjectHelper<IfcAlarmType,1>::Construct )
,       SchemaEntry("ifcdraughtingcallout",&STEP::ObjectHelper<IfcDraughtingCallout,1>::Construct )
,       SchemaEntry("ifcdimensioncurvedirectedcallout",&STEP::ObjectHelper<IfcDimensionCurveDirectedCallout,0>::Construct )
,       SchemaEntry("ifcangulardimension",&STEP::ObjectHelper<IfcAngularDimension,0>::Construct )
,       SchemaEntry("ifcproduct",&STEP::ObjectHelper<IfcProduct,2>::Construct )
,       SchemaEntry("ifcannotation",&STEP::ObjectHelper<IfcAnnotation,0>::Construct )
,       SchemaEntry("ifcstyleditem",&STEP::ObjectHelper<IfcStyledItem,3>::Construct )
,       SchemaEntry("ifcannotationoccurrence",&STEP::ObjectHelper<IfcAnnotationOccurrence,0>::Construct )
,       SchemaEntry("ifcannotationcurveoccurrence",&STEP::ObjectHelper<IfcAnnotationCurveOccurrence,0>::Construct )
,       SchemaEntry("ifcannotationfillarea",&STEP::ObjectHelper<IfcAnnotationFillArea,2>::Construct )
,       SchemaEntry("ifcannotationfillareaoccurrence",&STEP::ObjectHelper<IfcAnnotationFillAreaOccurrence,2>::Construct )
,       SchemaEntry("ifcannotationsurface",&STEP::ObjectHelper<IfcAnnotationSurface,2>::Construct )
,       SchemaEntry("ifcannotationsurfaceoccurrence",&STEP::ObjectHelper<IfcAnnotationSurfaceOccurrence,0>::Construct )
,       SchemaEntry("ifcannotationsymboloccurrence",&STEP::ObjectHelper<IfcAnnotationSymbolOccurrence,0>::Construct )
,       SchemaEntry("ifcannotationtextoccurrence",&STEP::ObjectHelper<IfcAnnotationTextOccurrence,0>::Construct )
,       SchemaEntry("ifcapplication",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcappliedvalue",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcappliedvaluerelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcapproval",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcapprovalactorrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcapprovalpropertyrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcapprovalrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcprofiledef",&STEP::ObjectHelper<IfcProfileDef,2>::Construct )
,       SchemaEntry("ifcarbitraryclosedprofiledef",&STEP::ObjectHelper<IfcArbitraryClosedProfileDef,1>::Construct )
,       SchemaEntry("ifcarbitraryopenprofiledef",&STEP::ObjectHelper<IfcArbitraryOpenProfileDef,1>::Construct )
,       SchemaEntry("ifcarbitraryprofiledefwithvoids",&STEP::ObjectHelper<IfcArbitraryProfileDefWithVoids,1>::Construct )
,       SchemaEntry("ifcgroup",&STEP::ObjectHelper<IfcGroup,0>::Construct )
,       SchemaEntry("ifcasset",&STEP::ObjectHelper<IfcAsset,9>::Construct )
,       SchemaEntry("ifcparameterizedprofiledef",&STEP::ObjectHelper<IfcParameterizedProfileDef,1>::Construct )
,       SchemaEntry("ifcishapeprofiledef",&STEP::ObjectHelper<IfcIShapeProfileDef,5>::Construct )
,       SchemaEntry("ifcasymmetricishapeprofiledef",&STEP::ObjectHelper<IfcAsymmetricIShapeProfileDef,4>::Construct )
,       SchemaEntry("ifcplacement",&STEP::ObjectHelper<IfcPlacement,1>::Construct )
,       SchemaEntry("ifcaxis1placement",&STEP::ObjectHelper<IfcAxis1Placement,1>::Construct )
,       SchemaEntry("ifcaxis2placement2d",&STEP::ObjectHelper<IfcAxis2Placement2D,1>::Construct )
,       SchemaEntry("ifcaxis2placement3d",&STEP::ObjectHelper<IfcAxis2Placement3D,2>::Construct )
,       SchemaEntry("ifcbsplinecurve",&STEP::ObjectHelper<IfcBSplineCurve,5>::Construct )
,       SchemaEntry("ifcelement",&STEP::ObjectHelper<IfcElement,1>::Construct )
,       SchemaEntry("ifcbuildingelement",&STEP::ObjectHelper<IfcBuildingElement,0>::Construct )
,       SchemaEntry("ifcbeam",&STEP::ObjectHelper<IfcBeam,0>::Construct )
,       SchemaEntry("ifcbuildingelementtype",&STEP::ObjectHelper<IfcBuildingElementType,0>::Construct )
,       SchemaEntry("ifcbeamtype",&STEP::ObjectHelper<IfcBeamType,1>::Construct )
,       SchemaEntry("ifcbeziercurve",&STEP::ObjectHelper<IfcBezierCurve,0>::Construct )
,       SchemaEntry("ifcsurfacetexture",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcblobtexture",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifccsgprimitive3d",&STEP::ObjectHelper<IfcCsgPrimitive3D,1>::Construct )
,       SchemaEntry("ifcblock",&STEP::ObjectHelper<IfcBlock,3>::Construct )
,       SchemaEntry("ifcboilertype",&STEP::ObjectHelper<IfcBoilerType,1>::Construct )
,       SchemaEntry("ifcbooleanresult",&STEP::ObjectHelper<IfcBooleanResult,3>::Construct )
,       SchemaEntry("ifcbooleanclippingresult",&STEP::ObjectHelper<IfcBooleanClippingResult,0>::Construct )
,       SchemaEntry("ifcboundarycondition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcboundaryedgecondition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcboundaryfacecondition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcboundarynodecondition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcboundarynodeconditionwarping",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcsurface",&STEP::ObjectHelper<IfcSurface,0>::Construct )
,       SchemaEntry("ifcboundedsurface",&STEP::ObjectHelper<IfcBoundedSurface,0>::Construct )
,       SchemaEntry("ifcboundingbox",&STEP::ObjectHelper<IfcBoundingBox,4>::Construct )
,       SchemaEntry("ifchalfspacesolid",&STEP::ObjectHelper<IfcHalfSpaceSolid,2>::Construct )
,       SchemaEntry("ifcboxedhalfspace",&STEP::ObjectHelper<IfcBoxedHalfSpace,1>::Construct )
,       SchemaEntry("ifcspatialstructureelement",&STEP::ObjectHelper<IfcSpatialStructureElement,2>::Construct )
,       SchemaEntry("ifcbuilding",&STEP::ObjectHelper<IfcBuilding,3>::Construct )
,       SchemaEntry("ifcbuildingelementcomponent",&STEP::ObjectHelper<IfcBuildingElementComponent,0>::Construct )
,       SchemaEntry("ifcbuildingelementpart",&STEP::ObjectHelper<IfcBuildingElementPart,0>::Construct )
,       SchemaEntry("ifcbuildingelementproxy",&STEP::ObjectHelper<IfcBuildingElementProxy,1>::Construct )
,       SchemaEntry("ifcbuildingelementproxytype",&STEP::ObjectHelper<IfcBuildingElementProxyType,1>::Construct )
,       SchemaEntry("ifcbuildingstorey",&STEP::ObjectHelper<IfcBuildingStorey,1>::Construct )
,       SchemaEntry("ifccshapeprofiledef",&STEP::ObjectHelper<IfcCShapeProfileDef,6>::Construct )
,       SchemaEntry("ifcflowfittingtype",&STEP::ObjectHelper<IfcFlowFittingType,0>::Construct )
,       SchemaEntry("ifccablecarrierfittingtype",&STEP::ObjectHelper<IfcCableCarrierFittingType,1>::Construct )
,       SchemaEntry("ifcflowsegmenttype",&STEP::ObjectHelper<IfcFlowSegmentType,0>::Construct )
,       SchemaEntry("ifccablecarriersegmenttype",&STEP::ObjectHelper<IfcCableCarrierSegmentType,1>::Construct )
,       SchemaEntry("ifccablesegmenttype",&STEP::ObjectHelper<IfcCableSegmentType,1>::Construct )
,       SchemaEntry("ifccalendardate",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpoint",&STEP::ObjectHelper<IfcPoint,0>::Construct )
,       SchemaEntry("ifccartesianpoint",&STEP::ObjectHelper<IfcCartesianPoint,1>::Construct )
,       SchemaEntry("ifccartesiantransformationoperator",&STEP::ObjectHelper<IfcCartesianTransformationOperator,4>::Construct )
,       SchemaEntry("ifccartesiantransformationoperator2d",&STEP::ObjectHelper<IfcCartesianTransformationOperator2D,0>::Construct )
,       SchemaEntry("ifccartesiantransformationoperator2dnonuniform",&STEP::ObjectHelper<IfcCartesianTransformationOperator2DnonUniform,1>::Construct )
,       SchemaEntry("ifccartesiantransformationoperator3d",&STEP::ObjectHelper<IfcCartesianTransformationOperator3D,1>::Construct )
,       SchemaEntry("ifccartesiantransformationoperator3dnonuniform",&STEP::ObjectHelper<IfcCartesianTransformationOperator3DnonUniform,2>::Construct )
,       SchemaEntry("ifccenterlineprofiledef",&STEP::ObjectHelper<IfcCenterLineProfileDef,1>::Construct )
,       SchemaEntry("ifcfeatureelement",&STEP::ObjectHelper<IfcFeatureElement,0>::Construct )
,       SchemaEntry("ifcfeatureelementsubtraction",&STEP::ObjectHelper<IfcFeatureElementSubtraction,0>::Construct )
,       SchemaEntry("ifcedgefeature",&STEP::ObjectHelper<IfcEdgeFeature,1>::Construct )
,       SchemaEntry("ifcchamferedgefeature",&STEP::ObjectHelper<IfcChamferEdgeFeature,2>::Construct )
,       SchemaEntry("ifcchillertype",&STEP::ObjectHelper<IfcChillerType,1>::Construct )
,       SchemaEntry("ifcconic",&STEP::ObjectHelper<IfcConic,1>::Construct )
,       SchemaEntry("ifccircle",&STEP::ObjectHelper<IfcCircle,1>::Construct )
,       SchemaEntry("ifccircleprofiledef",&STEP::ObjectHelper<IfcCircleProfileDef,1>::Construct )
,       SchemaEntry("ifccirclehollowprofiledef",&STEP::ObjectHelper<IfcCircleHollowProfileDef,1>::Construct )
,       SchemaEntry("ifcclassification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcclassificationitem",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcclassificationitemrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcclassificationnotation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcclassificationnotationfacet",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcexternalreference",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcclassificationreference",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctopologicalrepresentationitem",&STEP::ObjectHelper<IfcTopologicalRepresentationItem,0>::Construct )
,       SchemaEntry("ifcconnectedfaceset",&STEP::ObjectHelper<IfcConnectedFaceSet,1>::Construct )
,       SchemaEntry("ifcclosedshell",&STEP::ObjectHelper<IfcClosedShell,0>::Construct )
,       SchemaEntry("ifccoiltype",&STEP::ObjectHelper<IfcCoilType,1>::Construct )
,       SchemaEntry("ifccolourspecification",&STEP::ObjectHelper<IfcColourSpecification,1>::Construct )
,       SchemaEntry("ifccolourrgb",&STEP::ObjectHelper<IfcColourRgb,3>::Construct )
,       SchemaEntry("ifccolumn",&STEP::ObjectHelper<IfcColumn,0>::Construct )
,       SchemaEntry("ifccolumntype",&STEP::ObjectHelper<IfcColumnType,1>::Construct )
,       SchemaEntry("ifcproperty",&STEP::ObjectHelper<IfcProperty,2>::Construct )
,       SchemaEntry("ifccomplexproperty",&STEP::ObjectHelper<IfcComplexProperty,2>::Construct )
,       SchemaEntry("ifccompositecurvesegment",&STEP::ObjectHelper<IfcCompositeCurveSegment,3>::Construct )
,       SchemaEntry("ifccompositeprofiledef",&STEP::ObjectHelper<IfcCompositeProfileDef,2>::Construct )
,       SchemaEntry("ifcflowmovingdevicetype",&STEP::ObjectHelper<IfcFlowMovingDeviceType,0>::Construct )
,       SchemaEntry("ifccompressortype",&STEP::ObjectHelper<IfcCompressorType,1>::Construct )
,       SchemaEntry("ifccondensertype",&STEP::ObjectHelper<IfcCondenserType,1>::Construct )
,       SchemaEntry("ifccondition",&STEP::ObjectHelper<IfcCondition,0>::Construct )
,       SchemaEntry("ifcconditioncriterion",&STEP::ObjectHelper<IfcConditionCriterion,2>::Construct )
,       SchemaEntry("ifcconnectiongeometry",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcconnectioncurvegeometry",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcconnectionpointgeometry",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcconnectionpointeccentricity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcconnectionportgeometry",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcconnectionsurfacegeometry",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcconstraint",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcconstraintaggregationrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcconstraintclassificationrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcconstraintrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcresource",&STEP::ObjectHelper<IfcResource,0>::Construct )
,       SchemaEntry("ifcconstructionresource",&STEP::ObjectHelper<IfcConstructionResource,4>::Construct )
,       SchemaEntry("ifcconstructionequipmentresource",&STEP::ObjectHelper<IfcConstructionEquipmentResource,0>::Construct )
,       SchemaEntry("ifcconstructionmaterialresource",&STEP::ObjectHelper<IfcConstructionMaterialResource,2>::Construct )
,       SchemaEntry("ifcconstructionproductresource",&STEP::ObjectHelper<IfcConstructionProductResource,0>::Construct )
,       SchemaEntry("ifcnamedunit",&STEP::ObjectHelper<IfcNamedUnit,2>::Construct )
,       SchemaEntry("ifccontextdependentunit",&STEP::ObjectHelper<IfcContextDependentUnit,1>::Construct )
,       SchemaEntry("ifccontrollertype",&STEP::ObjectHelper<IfcControllerType,1>::Construct )
,       SchemaEntry("ifcconversionbasedunit",&STEP::ObjectHelper<IfcConversionBasedUnit,2>::Construct )
,       SchemaEntry("ifccooledbeamtype",&STEP::ObjectHelper<IfcCooledBeamType,1>::Construct )
,       SchemaEntry("ifccoolingtowertype",&STEP::ObjectHelper<IfcCoolingTowerType,1>::Construct )
,       SchemaEntry("ifccoordinateduniversaltimeoffset",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifccostitem",&STEP::ObjectHelper<IfcCostItem,0>::Construct )
,       SchemaEntry("ifccostschedule",&STEP::ObjectHelper<IfcCostSchedule,8>::Construct )
,       SchemaEntry("ifccostvalue",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifccovering",&STEP::ObjectHelper<IfcCovering,1>::Construct )
,       SchemaEntry("ifccoveringtype",&STEP::ObjectHelper<IfcCoveringType,1>::Construct )
,       SchemaEntry("ifccranerailashapeprofiledef",&STEP::ObjectHelper<IfcCraneRailAShapeProfileDef,12>::Construct )
,       SchemaEntry("ifccranerailfshapeprofiledef",&STEP::ObjectHelper<IfcCraneRailFShapeProfileDef,9>::Construct )
,       SchemaEntry("ifccrewresource",&STEP::ObjectHelper<IfcCrewResource,0>::Construct )
,       SchemaEntry("ifcsolidmodel",&STEP::ObjectHelper<IfcSolidModel,0>::Construct )
,       SchemaEntry("ifccsgsolid",&STEP::ObjectHelper<IfcCsgSolid,1>::Construct )
,       SchemaEntry("ifccurrencyrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifccurtainwall",&STEP::ObjectHelper<IfcCurtainWall,0>::Construct )
,       SchemaEntry("ifccurtainwalltype",&STEP::ObjectHelper<IfcCurtainWallType,1>::Construct )
,       SchemaEntry("ifccurveboundedplane",&STEP::ObjectHelper<IfcCurveBoundedPlane,3>::Construct )
,       SchemaEntry("ifcpresentationstyle",&STEP::ObjectHelper<IfcPresentationStyle,1>::Construct )
,       SchemaEntry("ifccurvestyle",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifccurvestylefont",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifccurvestylefontandscaling",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifccurvestylefontpattern",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdampertype",&STEP::ObjectHelper<IfcDamperType,1>::Construct )
,       SchemaEntry("ifcdateandtime",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdefinedsymbol",&STEP::ObjectHelper<IfcDefinedSymbol,2>::Construct )
,       SchemaEntry("ifcderivedprofiledef",&STEP::ObjectHelper<IfcDerivedProfileDef,3>::Construct )
,       SchemaEntry("ifcderivedunit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcderivedunitelement",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdiameterdimension",&STEP::ObjectHelper<IfcDiameterDimension,0>::Construct )
,       SchemaEntry("ifcdraughtingcalloutrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdimensioncalloutrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdimensioncurve",&STEP::ObjectHelper<IfcDimensionCurve,0>::Construct )
,       SchemaEntry("ifcterminatorsymbol",&STEP::ObjectHelper<IfcTerminatorSymbol,1>::Construct )
,       SchemaEntry("ifcdimensioncurveterminator",&STEP::ObjectHelper<IfcDimensionCurveTerminator,1>::Construct )
,       SchemaEntry("ifcdimensionpair",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdimensionalexponents",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdirection",&STEP::ObjectHelper<IfcDirection,1>::Construct )
,       SchemaEntry("ifcelementcomponent",&STEP::ObjectHelper<IfcElementComponent,0>::Construct )
,       SchemaEntry("ifcdiscreteaccessory",&STEP::ObjectHelper<IfcDiscreteAccessory,0>::Construct )
,       SchemaEntry("ifcelementcomponenttype",&STEP::ObjectHelper<IfcElementComponentType,0>::Construct )
,       SchemaEntry("ifcdiscreteaccessorytype",&STEP::ObjectHelper<IfcDiscreteAccessoryType,0>::Construct )
,       SchemaEntry("ifcdistributionelement",&STEP::ObjectHelper<IfcDistributionElement,0>::Construct )
,       SchemaEntry("ifcdistributionflowelement",&STEP::ObjectHelper<IfcDistributionFlowElement,0>::Construct )
,       SchemaEntry("ifcdistributionchamberelement",&STEP::ObjectHelper<IfcDistributionChamberElement,0>::Construct )
,       SchemaEntry("ifcdistributionchamberelementtype",&STEP::ObjectHelper<IfcDistributionChamberElementType,1>::Construct )
,       SchemaEntry("ifcdistributioncontrolelement",&STEP::ObjectHelper<IfcDistributionControlElement,1>::Construct )
,       SchemaEntry("ifcport",&STEP::ObjectHelper<IfcPort,0>::Construct )
,       SchemaEntry("ifcdistributionport",&STEP::ObjectHelper<IfcDistributionPort,1>::Construct )
,       SchemaEntry("ifcdocumentelectronicformat",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdocumentinformation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdocumentinformationrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdocumentreference",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdoor",&STEP::ObjectHelper<IfcDoor,2>::Construct )
,       SchemaEntry("ifcpropertydefinition",&STEP::ObjectHelper<IfcPropertyDefinition,0>::Construct )
,       SchemaEntry("ifcpropertysetdefinition",&STEP::ObjectHelper<IfcPropertySetDefinition,0>::Construct )
,       SchemaEntry("ifcdoorliningproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdoorpanelproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdoorstyle",&STEP::ObjectHelper<IfcDoorStyle,4>::Construct )
,       SchemaEntry("ifcpredefineditem",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpredefinedcolour",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdraughtingpredefinedcolour",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpredefinedcurvefont",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdraughtingpredefinedcurvefont",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpredefinedtextfont",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcdraughtingpredefinedtextfont",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcductfittingtype",&STEP::ObjectHelper<IfcDuctFittingType,1>::Construct )
,       SchemaEntry("ifcductsegmenttype",&STEP::ObjectHelper<IfcDuctSegmentType,1>::Construct )
,       SchemaEntry("ifcflowtreatmentdevicetype",&STEP::ObjectHelper<IfcFlowTreatmentDeviceType,0>::Construct )
,       SchemaEntry("ifcductsilencertype",&STEP::ObjectHelper<IfcDuctSilencerType,1>::Construct )
,       SchemaEntry("ifcedge",&STEP::ObjectHelper<IfcEdge,2>::Construct )
,       SchemaEntry("ifcedgecurve",&STEP::ObjectHelper<IfcEdgeCurve,2>::Construct )
,       SchemaEntry("ifcloop",&STEP::ObjectHelper<IfcLoop,0>::Construct )
,       SchemaEntry("ifcedgeloop",&STEP::ObjectHelper<IfcEdgeLoop,1>::Construct )
,       SchemaEntry("ifcelectricappliancetype",&STEP::ObjectHelper<IfcElectricApplianceType,1>::Construct )
,       SchemaEntry("ifcflowcontroller",&STEP::ObjectHelper<IfcFlowController,0>::Construct )
,       SchemaEntry("ifcelectricdistributionpoint",&STEP::ObjectHelper<IfcElectricDistributionPoint,2>::Construct )
,       SchemaEntry("ifcflowstoragedevicetype",&STEP::ObjectHelper<IfcFlowStorageDeviceType,0>::Construct )
,       SchemaEntry("ifcelectricflowstoragedevicetype",&STEP::ObjectHelper<IfcElectricFlowStorageDeviceType,1>::Construct )
,       SchemaEntry("ifcelectricgeneratortype",&STEP::ObjectHelper<IfcElectricGeneratorType,1>::Construct )
,       SchemaEntry("ifcelectricheatertype",&STEP::ObjectHelper<IfcElectricHeaterType,1>::Construct )
,       SchemaEntry("ifcelectricmotortype",&STEP::ObjectHelper<IfcElectricMotorType,1>::Construct )
,       SchemaEntry("ifcelectrictimecontroltype",&STEP::ObjectHelper<IfcElectricTimeControlType,1>::Construct )
,       SchemaEntry("ifcenergyproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcelectricalbaseproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcsystem",&STEP::ObjectHelper<IfcSystem,0>::Construct )
,       SchemaEntry("ifcelectricalcircuit",&STEP::ObjectHelper<IfcElectricalCircuit,0>::Construct )
,       SchemaEntry("ifcelectricalelement",&STEP::ObjectHelper<IfcElectricalElement,0>::Construct )
,       SchemaEntry("ifcelementassembly",&STEP::ObjectHelper<IfcElementAssembly,2>::Construct )
,       SchemaEntry("ifcelementquantity",&STEP::ObjectHelper<IfcElementQuantity,2>::Construct )
,       SchemaEntry("ifcelementarysurface",&STEP::ObjectHelper<IfcElementarySurface,1>::Construct )
,       SchemaEntry("ifcellipse",&STEP::ObjectHelper<IfcEllipse,2>::Construct )
,       SchemaEntry("ifcellipseprofiledef",&STEP::ObjectHelper<IfcEllipseProfileDef,2>::Construct )
,       SchemaEntry("ifcenergyconversiondevice",&STEP::ObjectHelper<IfcEnergyConversionDevice,0>::Construct )
,       SchemaEntry("ifcenvironmentalimpactvalue",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcequipmentelement",&STEP::ObjectHelper<IfcEquipmentElement,0>::Construct )
,       SchemaEntry("ifcequipmentstandard",&STEP::ObjectHelper<IfcEquipmentStandard,0>::Construct )
,       SchemaEntry("ifcevaporativecoolertype",&STEP::ObjectHelper<IfcEvaporativeCoolerType,1>::Construct )
,       SchemaEntry("ifcevaporatortype",&STEP::ObjectHelper<IfcEvaporatorType,1>::Construct )
,       SchemaEntry("ifcmaterialproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcextendedmaterialproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcexternallydefinedhatchstyle",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcexternallydefinedsurfacestyle",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcexternallydefinedsymbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcexternallydefinedtextfont",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcsweptareasolid",&STEP::ObjectHelper<IfcSweptAreaSolid,2>::Construct )
,       SchemaEntry("ifcextrudedareasolid",&STEP::ObjectHelper<IfcExtrudedAreaSolid,2>::Construct )
,       SchemaEntry("ifcface",&STEP::ObjectHelper<IfcFace,1>::Construct )
,       SchemaEntry("ifcfacebasedsurfacemodel",&STEP::ObjectHelper<IfcFaceBasedSurfaceModel,1>::Construct )
,       SchemaEntry("ifcfacebound",&STEP::ObjectHelper<IfcFaceBound,2>::Construct )
,       SchemaEntry("ifcfaceouterbound",&STEP::ObjectHelper<IfcFaceOuterBound,0>::Construct )
,       SchemaEntry("ifcfacesurface",&STEP::ObjectHelper<IfcFaceSurface,2>::Construct )
,       SchemaEntry("ifcmanifoldsolidbrep",&STEP::ObjectHelper<IfcManifoldSolidBrep,1>::Construct )
,       SchemaEntry("ifcfacetedbrep",&STEP::ObjectHelper<IfcFacetedBrep,0>::Construct )
,       SchemaEntry("ifcfacetedbrepwithvoids",&STEP::ObjectHelper<IfcFacetedBrepWithVoids,1>::Construct )
,       SchemaEntry("ifcstructuralconnectioncondition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcfailureconnectioncondition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcfantype",&STEP::ObjectHelper<IfcFanType,1>::Construct )
,       SchemaEntry("ifcfastener",&STEP::ObjectHelper<IfcFastener,0>::Construct )
,       SchemaEntry("ifcfastenertype",&STEP::ObjectHelper<IfcFastenerType,0>::Construct )
,       SchemaEntry("ifcfeatureelementaddition",&STEP::ObjectHelper<IfcFeatureElementAddition,0>::Construct )
,       SchemaEntry("ifcfillareastyle",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcfillareastylehatching",&STEP::ObjectHelper<IfcFillAreaStyleHatching,5>::Construct )
,       SchemaEntry("ifcfillareastyletilesymbolwithstyle",&STEP::ObjectHelper<IfcFillAreaStyleTileSymbolWithStyle,1>::Construct )
,       SchemaEntry("ifcfillareastyletiles",&STEP::ObjectHelper<IfcFillAreaStyleTiles,3>::Construct )
,       SchemaEntry("ifcfiltertype",&STEP::ObjectHelper<IfcFilterType,1>::Construct )
,       SchemaEntry("ifcfiresuppressionterminaltype",&STEP::ObjectHelper<IfcFireSuppressionTerminalType,1>::Construct )
,       SchemaEntry("ifcflowfitting",&STEP::ObjectHelper<IfcFlowFitting,0>::Construct )
,       SchemaEntry("ifcflowinstrumenttype",&STEP::ObjectHelper<IfcFlowInstrumentType,1>::Construct )
,       SchemaEntry("ifcflowmetertype",&STEP::ObjectHelper<IfcFlowMeterType,1>::Construct )
,       SchemaEntry("ifcflowmovingdevice",&STEP::ObjectHelper<IfcFlowMovingDevice,0>::Construct )
,       SchemaEntry("ifcflowsegment",&STEP::ObjectHelper<IfcFlowSegment,0>::Construct )
,       SchemaEntry("ifcflowstoragedevice",&STEP::ObjectHelper<IfcFlowStorageDevice,0>::Construct )
,       SchemaEntry("ifcflowterminal",&STEP::ObjectHelper<IfcFlowTerminal,0>::Construct )
,       SchemaEntry("ifcflowtreatmentdevice",&STEP::ObjectHelper<IfcFlowTreatmentDevice,0>::Construct )
,       SchemaEntry("ifcfluidflowproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcfooting",&STEP::ObjectHelper<IfcFooting,1>::Construct )
,       SchemaEntry("ifcfuelproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcfurnishingelement",&STEP::ObjectHelper<IfcFurnishingElement,0>::Construct )
,       SchemaEntry("ifcfurnishingelementtype",&STEP::ObjectHelper<IfcFurnishingElementType,0>::Construct )
,       SchemaEntry("ifcfurniturestandard",&STEP::ObjectHelper<IfcFurnitureStandard,0>::Construct )
,       SchemaEntry("ifcfurnituretype",&STEP::ObjectHelper<IfcFurnitureType,1>::Construct )
,       SchemaEntry("ifcgasterminaltype",&STEP::ObjectHelper<IfcGasTerminalType,1>::Construct )
,       SchemaEntry("ifcgeneralmaterialproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcprofileproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcgeneralprofileproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcgeometricset",&STEP::ObjectHelper<IfcGeometricSet,1>::Construct )
,       SchemaEntry("ifcgeometriccurveset",&STEP::ObjectHelper<IfcGeometricCurveSet,0>::Construct )
,       SchemaEntry("ifcrepresentationcontext",&STEP::ObjectHelper<IfcRepresentationContext,2>::Construct )
,       SchemaEntry("ifcgeometricrepresentationcontext",&STEP::ObjectHelper<IfcGeometricRepresentationContext,4>::Construct )
,       SchemaEntry("ifcgeometricrepresentationsubcontext",&STEP::ObjectHelper<IfcGeometricRepresentationSubContext,4>::Construct )
,       SchemaEntry("ifcgrid",&STEP::ObjectHelper<IfcGrid,3>::Construct )
,       SchemaEntry("ifcgridaxis",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcobjectplacement",&STEP::ObjectHelper<IfcObjectPlacement,0>::Construct )
,       SchemaEntry("ifcgridplacement",&STEP::ObjectHelper<IfcGridPlacement,2>::Construct )
,       SchemaEntry("ifcheatexchangertype",&STEP::ObjectHelper<IfcHeatExchangerType,1>::Construct )
,       SchemaEntry("ifchumidifiertype",&STEP::ObjectHelper<IfcHumidifierType,1>::Construct )
,       SchemaEntry("ifchygroscopicmaterialproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcimagetexture",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcinventory",&STEP::ObjectHelper<IfcInventory,6>::Construct )
,       SchemaEntry("ifctimeseries",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcirregulartimeseries",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcirregulartimeseriesvalue",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcjunctionboxtype",&STEP::ObjectHelper<IfcJunctionBoxType,1>::Construct )
,       SchemaEntry("ifclshapeprofiledef",&STEP::ObjectHelper<IfcLShapeProfileDef,8>::Construct )
,       SchemaEntry("ifclaborresource",&STEP::ObjectHelper<IfcLaborResource,1>::Construct )
,       SchemaEntry("ifclamptype",&STEP::ObjectHelper<IfcLampType,1>::Construct )
,       SchemaEntry("ifclibraryinformation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifclibraryreference",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifclightdistributiondata",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifclightfixturetype",&STEP::ObjectHelper<IfcLightFixtureType,1>::Construct )
,       SchemaEntry("ifclightintensitydistribution",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifclightsource",&STEP::ObjectHelper<IfcLightSource,4>::Construct )
,       SchemaEntry("ifclightsourceambient",&STEP::ObjectHelper<IfcLightSourceAmbient,0>::Construct )
,       SchemaEntry("ifclightsourcedirectional",&STEP::ObjectHelper<IfcLightSourceDirectional,1>::Construct )
,       SchemaEntry("ifclightsourcegoniometric",&STEP::ObjectHelper<IfcLightSourceGoniometric,6>::Construct )
,       SchemaEntry("ifclightsourcepositional",&STEP::ObjectHelper<IfcLightSourcePositional,5>::Construct )
,       SchemaEntry("ifclightsourcespot",&STEP::ObjectHelper<IfcLightSourceSpot,4>::Construct )
,       SchemaEntry("ifcline",&STEP::ObjectHelper<IfcLine,2>::Construct )
,       SchemaEntry("ifclineardimension",&STEP::ObjectHelper<IfcLinearDimension,0>::Construct )
,       SchemaEntry("ifclocalplacement",&STEP::ObjectHelper<IfcLocalPlacement,2>::Construct )
,       SchemaEntry("ifclocaltime",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcmappeditem",&STEP::ObjectHelper<IfcMappedItem,2>::Construct )
,       SchemaEntry("ifcmaterial",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcmaterialclassificationrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcproductrepresentation",&STEP::ObjectHelper<IfcProductRepresentation,3>::Construct )
,       SchemaEntry("ifcmaterialdefinitionrepresentation",&STEP::ObjectHelper<IfcMaterialDefinitionRepresentation,1>::Construct )
,       SchemaEntry("ifcmateriallayer",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcmateriallayerset",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcmateriallayersetusage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcmateriallist",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcmeasurewithunit",&STEP::ObjectHelper<IfcMeasureWithUnit,2>::Construct )
,       SchemaEntry("ifcmechanicalmaterialproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcmechanicalconcretematerialproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcmechanicalfastener",&STEP::ObjectHelper<IfcMechanicalFastener,2>::Construct )
,       SchemaEntry("ifcmechanicalfastenertype",&STEP::ObjectHelper<IfcMechanicalFastenerType,0>::Construct )
,       SchemaEntry("ifcmechanicalsteelmaterialproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcmember",&STEP::ObjectHelper<IfcMember,0>::Construct )
,       SchemaEntry("ifcmembertype",&STEP::ObjectHelper<IfcMemberType,1>::Construct )
,       SchemaEntry("ifcmetric",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcmonetaryunit",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcmotorconnectiontype",&STEP::ObjectHelper<IfcMotorConnectionType,1>::Construct )
,       SchemaEntry("ifcprocess",&STEP::ObjectHelper<IfcProcess,0>::Construct )
,       SchemaEntry("ifctask",&STEP::ObjectHelper<IfcTask,5>::Construct )
,       SchemaEntry("ifcmove",&STEP::ObjectHelper<IfcMove,3>::Construct )
,       SchemaEntry("ifcobjective",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcoccupant",&STEP::ObjectHelper<IfcOccupant,1>::Construct )
,       SchemaEntry("ifcoffsetcurve2d",&STEP::ObjectHelper<IfcOffsetCurve2D,3>::Construct )
,       SchemaEntry("ifcoffsetcurve3d",&STEP::ObjectHelper<IfcOffsetCurve3D,4>::Construct )
,       SchemaEntry("ifconedirectionrepeatfactor",&STEP::ObjectHelper<IfcOneDirectionRepeatFactor,1>::Construct )
,       SchemaEntry("ifcopenshell",&STEP::ObjectHelper<IfcOpenShell,0>::Construct )
,       SchemaEntry("ifcopeningelement",&STEP::ObjectHelper<IfcOpeningElement,0>::Construct )
,       SchemaEntry("ifcopticalmaterialproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcorderaction",&STEP::ObjectHelper<IfcOrderAction,1>::Construct )
,       SchemaEntry("ifcorganization",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcorganizationrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcorientededge",&STEP::ObjectHelper<IfcOrientedEdge,2>::Construct )
,       SchemaEntry("ifcoutlettype",&STEP::ObjectHelper<IfcOutletType,1>::Construct )
,       SchemaEntry("ifcownerhistory",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpath",&STEP::ObjectHelper<IfcPath,1>::Construct )
,       SchemaEntry("ifcperformancehistory",&STEP::ObjectHelper<IfcPerformanceHistory,1>::Construct )
,       SchemaEntry("ifcpermeablecoveringproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpermit",&STEP::ObjectHelper<IfcPermit,1>::Construct )
,       SchemaEntry("ifcperson",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpersonandorganization",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcphysicalquantity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcphysicalcomplexquantity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcphysicalsimplequantity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpile",&STEP::ObjectHelper<IfcPile,2>::Construct )
,       SchemaEntry("ifcpipefittingtype",&STEP::ObjectHelper<IfcPipeFittingType,1>::Construct )
,       SchemaEntry("ifcpipesegmenttype",&STEP::ObjectHelper<IfcPipeSegmentType,1>::Construct )
,       SchemaEntry("ifcpixeltexture",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcplanarextent",&STEP::ObjectHelper<IfcPlanarExtent,2>::Construct )
,       SchemaEntry("ifcplanarbox",&STEP::ObjectHelper<IfcPlanarBox,1>::Construct )
,       SchemaEntry("ifcplane",&STEP::ObjectHelper<IfcPlane,0>::Construct )
,       SchemaEntry("ifcplate",&STEP::ObjectHelper<IfcPlate,0>::Construct )
,       SchemaEntry("ifcplatetype",&STEP::ObjectHelper<IfcPlateType,1>::Construct )
,       SchemaEntry("ifcpointoncurve",&STEP::ObjectHelper<IfcPointOnCurve,2>::Construct )
,       SchemaEntry("ifcpointonsurface",&STEP::ObjectHelper<IfcPointOnSurface,3>::Construct )
,       SchemaEntry("ifcpolyloop",&STEP::ObjectHelper<IfcPolyLoop,1>::Construct )
,       SchemaEntry("ifcpolygonalboundedhalfspace",&STEP::ObjectHelper<IfcPolygonalBoundedHalfSpace,2>::Construct )
,       SchemaEntry("ifcpolyline",&STEP::ObjectHelper<IfcPolyline,1>::Construct )
,       SchemaEntry("ifcpostaladdress",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpredefinedsymbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpredefineddimensionsymbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpredefinedpointmarkersymbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpredefinedterminatorsymbol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpresentationlayerassignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpresentationlayerwithstyle",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpresentationstyleassignment",&STEP::ObjectHelper<IfcPresentationStyleAssignment,1>::Construct )
,       SchemaEntry("ifcprocedure",&STEP::ObjectHelper<IfcProcedure,3>::Construct )
,       SchemaEntry("ifcproductdefinitionshape",&STEP::ObjectHelper<IfcProductDefinitionShape,0>::Construct )
,       SchemaEntry("ifcproductsofcombustionproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcproject",&STEP::ObjectHelper<IfcProject,4>::Construct )
,       SchemaEntry("ifcprojectorder",&STEP::ObjectHelper<IfcProjectOrder,3>::Construct )
,       SchemaEntry("ifcprojectorderrecord",&STEP::ObjectHelper<IfcProjectOrderRecord,2>::Construct )
,       SchemaEntry("ifcprojectioncurve",&STEP::ObjectHelper<IfcProjectionCurve,0>::Construct )
,       SchemaEntry("ifcprojectionelement",&STEP::ObjectHelper<IfcProjectionElement,0>::Construct )
,       SchemaEntry("ifcsimpleproperty",&STEP::ObjectHelper<IfcSimpleProperty,0>::Construct )
,       SchemaEntry("ifcpropertyboundedvalue",&STEP::ObjectHelper<IfcPropertyBoundedValue,3>::Construct )
,       SchemaEntry("ifcpropertyconstraintrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpropertydependencyrelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpropertyenumeratedvalue",&STEP::ObjectHelper<IfcPropertyEnumeratedValue,2>::Construct )
,       SchemaEntry("ifcpropertyenumeration",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcpropertylistvalue",&STEP::ObjectHelper<IfcPropertyListValue,2>::Construct )
,       SchemaEntry("ifcpropertyreferencevalue",&STEP::ObjectHelper<IfcPropertyReferenceValue,2>::Construct )
,       SchemaEntry("ifcpropertyset",&STEP::ObjectHelper<IfcPropertySet,1>::Construct )
,       SchemaEntry("ifcpropertysinglevalue",&STEP::ObjectHelper<IfcPropertySingleValue,2>::Construct )
,       SchemaEntry("ifcpropertytablevalue",&STEP::ObjectHelper<IfcPropertyTableValue,5>::Construct )
,       SchemaEntry("ifcprotectivedevicetype",&STEP::ObjectHelper<IfcProtectiveDeviceType,1>::Construct )
,       SchemaEntry("ifcproxy",&STEP::ObjectHelper<IfcProxy,2>::Construct )
,       SchemaEntry("ifcpumptype",&STEP::ObjectHelper<IfcPumpType,1>::Construct )
,       SchemaEntry("ifcquantityarea",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcquantitycount",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcquantitylength",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcquantitytime",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcquantityvolume",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcquantityweight",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcradiusdimension",&STEP::ObjectHelper<IfcRadiusDimension,0>::Construct )
,       SchemaEntry("ifcrailing",&STEP::ObjectHelper<IfcRailing,1>::Construct )
,       SchemaEntry("ifcrailingtype",&STEP::ObjectHelper<IfcRailingType,1>::Construct )
,       SchemaEntry("ifcramp",&STEP::ObjectHelper<IfcRamp,1>::Construct )
,       SchemaEntry("ifcrampflight",&STEP::ObjectHelper<IfcRampFlight,0>::Construct )
,       SchemaEntry("ifcrampflighttype",&STEP::ObjectHelper<IfcRampFlightType,1>::Construct )
,       SchemaEntry("ifcrationalbeziercurve",&STEP::ObjectHelper<IfcRationalBezierCurve,1>::Construct )
,       SchemaEntry("ifcrectangleprofiledef",&STEP::ObjectHelper<IfcRectangleProfileDef,2>::Construct )
,       SchemaEntry("ifcrectanglehollowprofiledef",&STEP::ObjectHelper<IfcRectangleHollowProfileDef,3>::Construct )
,       SchemaEntry("ifcrectangularpyramid",&STEP::ObjectHelper<IfcRectangularPyramid,3>::Construct )
,       SchemaEntry("ifcrectangulartrimmedsurface",&STEP::ObjectHelper<IfcRectangularTrimmedSurface,7>::Construct )
,       SchemaEntry("ifcreferencesvaluedocument",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcregulartimeseries",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcreinforcementbarproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcreinforcementdefinitionproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcreinforcingelement",&STEP::ObjectHelper<IfcReinforcingElement,1>::Construct )
,       SchemaEntry("ifcreinforcingbar",&STEP::ObjectHelper<IfcReinforcingBar,5>::Construct )
,       SchemaEntry("ifcreinforcingmesh",&STEP::ObjectHelper<IfcReinforcingMesh,8>::Construct )
,       SchemaEntry("ifcrelationship",&STEP::ObjectHelper<IfcRelationship,0>::Construct )
,       SchemaEntry("ifcreldecomposes",&STEP::ObjectHelper<IfcRelDecomposes,2>::Construct )
,       SchemaEntry("ifcrelaggregates",&STEP::ObjectHelper<IfcRelAggregates,0>::Construct )
,       SchemaEntry("ifcrelassigns",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassignstocontrol",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassignstasks",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassignstoactor",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassignstogroup",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassignstoprocess",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassignstoproduct",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassignstoprojectorder",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassignstoresource",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassociates",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassociatesappliedvalue",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassociatesapproval",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassociatesclassification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassociatesconstraint",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassociatesdocument",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassociateslibrary",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassociatesmaterial",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelassociatesprofileproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelconnects",&STEP::ObjectHelper<IfcRelConnects,0>::Construct )
,       SchemaEntry("ifcrelconnectselements",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelconnectspathelements",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelconnectsporttoelement",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelconnectsports",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelconnectsstructuralactivity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelconnectsstructuralelement",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelconnectsstructuralmember",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelconnectswitheccentricity",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelconnectswithrealizingelements",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelcontainedinspatialstructure",&STEP::ObjectHelper<IfcRelContainedInSpatialStructure,2>::Construct )
,       SchemaEntry("ifcrelcoversbldgelements",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelcoversspaces",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcreldefines",&STEP::ObjectHelper<IfcRelDefines,1>::Construct )
,       SchemaEntry("ifcreldefinesbyproperties",&STEP::ObjectHelper<IfcRelDefinesByProperties,1>::Construct )
,       SchemaEntry("ifcreldefinesbytype",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelfillselement",&STEP::ObjectHelper<IfcRelFillsElement,2>::Construct )
,       SchemaEntry("ifcrelflowcontrolelements",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelinteractionrequirements",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelnests",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcreloccupiesspaces",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcreloverridesproperties",&STEP::ObjectHelper<IfcRelOverridesProperties,1>::Construct )
,       SchemaEntry("ifcrelprojectselement",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelreferencedinspatialstructure",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelschedulescostitems",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelsequence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelservicesbuildings",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelspaceboundary",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrelvoidselement",&STEP::ObjectHelper<IfcRelVoidsElement,2>::Construct )
,       SchemaEntry("ifcrelaxation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrepresentation",&STEP::ObjectHelper<IfcRepresentation,4>::Construct )
,       SchemaEntry("ifcrepresentationmap",&STEP::ObjectHelper<IfcRepresentationMap,2>::Construct )
,       SchemaEntry("ifcrevolvedareasolid",&STEP::ObjectHelper<IfcRevolvedAreaSolid,2>::Construct )
,       SchemaEntry("ifcribplateprofileproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcrightcircularcone",&STEP::ObjectHelper<IfcRightCircularCone,2>::Construct )
,       SchemaEntry("ifcrightcircularcylinder",&STEP::ObjectHelper<IfcRightCircularCylinder,2>::Construct )
,       SchemaEntry("ifcroof",&STEP::ObjectHelper<IfcRoof,1>::Construct )
,       SchemaEntry("ifcroundededgefeature",&STEP::ObjectHelper<IfcRoundedEdgeFeature,1>::Construct )
,       SchemaEntry("ifcroundedrectangleprofiledef",&STEP::ObjectHelper<IfcRoundedRectangleProfileDef,1>::Construct )
,       SchemaEntry("ifcsiunit",&STEP::ObjectHelper<IfcSIUnit,2>::Construct )
,       SchemaEntry("ifcsanitaryterminaltype",&STEP::ObjectHelper<IfcSanitaryTerminalType,1>::Construct )
,       SchemaEntry("ifcscheduletimecontrol",&STEP::ObjectHelper<IfcScheduleTimeControl,18>::Construct )
,       SchemaEntry("ifcsectionproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcsectionreinforcementproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcsectionedspine",&STEP::ObjectHelper<IfcSectionedSpine,3>::Construct )
,       SchemaEntry("ifcsensortype",&STEP::ObjectHelper<IfcSensorType,1>::Construct )
,       SchemaEntry("ifcservicelife",&STEP::ObjectHelper<IfcServiceLife,2>::Construct )
,       SchemaEntry("ifcservicelifefactor",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcshapeaspect",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcshapemodel",&STEP::ObjectHelper<IfcShapeModel,0>::Construct )
,       SchemaEntry("ifcshaperepresentation",&STEP::ObjectHelper<IfcShapeRepresentation,0>::Construct )
,       SchemaEntry("ifcshellbasedsurfacemodel",&STEP::ObjectHelper<IfcShellBasedSurfaceModel,1>::Construct )
,       SchemaEntry("ifcsite",&STEP::ObjectHelper<IfcSite,5>::Construct )
,       SchemaEntry("ifcslab",&STEP::ObjectHelper<IfcSlab,1>::Construct )
,       SchemaEntry("ifcslabtype",&STEP::ObjectHelper<IfcSlabType,1>::Construct )
,       SchemaEntry("ifcslippageconnectioncondition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcsoundproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcsoundvalue",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcspace",&STEP::ObjectHelper<IfcSpace,2>::Construct )
,       SchemaEntry("ifcspaceheatertype",&STEP::ObjectHelper<IfcSpaceHeaterType,1>::Construct )
,       SchemaEntry("ifcspaceprogram",&STEP::ObjectHelper<IfcSpaceProgram,5>::Construct )
,       SchemaEntry("ifcspacethermalloadproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcspatialstructureelementtype",&STEP::ObjectHelper<IfcSpatialStructureElementType,0>::Construct )
,       SchemaEntry("ifcspacetype",&STEP::ObjectHelper<IfcSpaceType,1>::Construct )
,       SchemaEntry("ifcsphere",&STEP::ObjectHelper<IfcSphere,1>::Construct )
,       SchemaEntry("ifcstackterminaltype",&STEP::ObjectHelper<IfcStackTerminalType,1>::Construct )
,       SchemaEntry("ifcstair",&STEP::ObjectHelper<IfcStair,1>::Construct )
,       SchemaEntry("ifcstairflight",&STEP::ObjectHelper<IfcStairFlight,4>::Construct )
,       SchemaEntry("ifcstairflighttype",&STEP::ObjectHelper<IfcStairFlightType,1>::Construct )
,       SchemaEntry("ifcstructuralactivity",&STEP::ObjectHelper<IfcStructuralActivity,2>::Construct )
,       SchemaEntry("ifcstructuralaction",&STEP::ObjectHelper<IfcStructuralAction,2>::Construct )
,       SchemaEntry("ifcstructuralanalysismodel",&STEP::ObjectHelper<IfcStructuralAnalysisModel,4>::Construct )
,       SchemaEntry("ifcstructuralitem",&STEP::ObjectHelper<IfcStructuralItem,0>::Construct )
,       SchemaEntry("ifcstructuralconnection",&STEP::ObjectHelper<IfcStructuralConnection,1>::Construct )
,       SchemaEntry("ifcstructuralcurveconnection",&STEP::ObjectHelper<IfcStructuralCurveConnection,0>::Construct )
,       SchemaEntry("ifcstructuralmember",&STEP::ObjectHelper<IfcStructuralMember,0>::Construct )
,       SchemaEntry("ifcstructuralcurvemember",&STEP::ObjectHelper<IfcStructuralCurveMember,1>::Construct )
,       SchemaEntry("ifcstructuralcurvemembervarying",&STEP::ObjectHelper<IfcStructuralCurveMemberVarying,0>::Construct )
,       SchemaEntry("ifcstructurallinearaction",&STEP::ObjectHelper<IfcStructuralLinearAction,1>::Construct )
,       SchemaEntry("ifcstructurallinearactionvarying",&STEP::ObjectHelper<IfcStructuralLinearActionVarying,2>::Construct )
,       SchemaEntry("ifcstructuralload",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcstructuralloadgroup",&STEP::ObjectHelper<IfcStructuralLoadGroup,5>::Construct )
,       SchemaEntry("ifcstructuralloadstatic",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcstructuralloadlinearforce",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcstructuralloadplanarforce",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcstructuralloadsingledisplacement",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcstructuralloadsingledisplacementdistortion",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcstructuralloadsingleforce",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcstructuralloadsingleforcewarping",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcstructuralloadtemperature",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcstructuralplanaraction",&STEP::ObjectHelper<IfcStructuralPlanarAction,1>::Construct )
,       SchemaEntry("ifcstructuralplanaractionvarying",&STEP::ObjectHelper<IfcStructuralPlanarActionVarying,2>::Construct )
,       SchemaEntry("ifcstructuralpointaction",&STEP::ObjectHelper<IfcStructuralPointAction,0>::Construct )
,       SchemaEntry("ifcstructuralpointconnection",&STEP::ObjectHelper<IfcStructuralPointConnection,0>::Construct )
,       SchemaEntry("ifcstructuralreaction",&STEP::ObjectHelper<IfcStructuralReaction,0>::Construct )
,       SchemaEntry("ifcstructuralpointreaction",&STEP::ObjectHelper<IfcStructuralPointReaction,0>::Construct )
,       SchemaEntry("ifcstructuralprofileproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcstructuralresultgroup",&STEP::ObjectHelper<IfcStructuralResultGroup,3>::Construct )
,       SchemaEntry("ifcstructuralsteelprofileproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcstructuralsurfaceconnection",&STEP::ObjectHelper<IfcStructuralSurfaceConnection,0>::Construct )
,       SchemaEntry("ifcstructuralsurfacemember",&STEP::ObjectHelper<IfcStructuralSurfaceMember,2>::Construct )
,       SchemaEntry("ifcstructuralsurfacemembervarying",&STEP::ObjectHelper<IfcStructuralSurfaceMemberVarying,2>::Construct )
,       SchemaEntry("ifcstructureddimensioncallout",&STEP::ObjectHelper<IfcStructuredDimensionCallout,0>::Construct )
,       SchemaEntry("ifcstylemodel",&STEP::ObjectHelper<IfcStyleModel,0>::Construct )
,       SchemaEntry("ifcstyledrepresentation",&STEP::ObjectHelper<IfcStyledRepresentation,0>::Construct )
,       SchemaEntry("ifcsubcontractresource",&STEP::ObjectHelper<IfcSubContractResource,2>::Construct )
,       SchemaEntry("ifcsubedge",&STEP::ObjectHelper<IfcSubedge,1>::Construct )
,       SchemaEntry("ifcsurfacecurvesweptareasolid",&STEP::ObjectHelper<IfcSurfaceCurveSweptAreaSolid,4>::Construct )
,       SchemaEntry("ifcsweptsurface",&STEP::ObjectHelper<IfcSweptSurface,2>::Construct )
,       SchemaEntry("ifcsurfaceoflinearextrusion",&STEP::ObjectHelper<IfcSurfaceOfLinearExtrusion,2>::Construct )
,       SchemaEntry("ifcsurfaceofrevolution",&STEP::ObjectHelper<IfcSurfaceOfRevolution,1>::Construct )
,       SchemaEntry("ifcsurfacestyle",&STEP::ObjectHelper<IfcSurfaceStyle,2>::Construct )
,       SchemaEntry("ifcsurfacestylelighting",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcsurfacestylerefraction",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcsurfacestyleshading",&STEP::ObjectHelper<IfcSurfaceStyleShading,1>::Construct )
,       SchemaEntry("ifcsurfacestylerendering",&STEP::ObjectHelper<IfcSurfaceStyleRendering,8>::Construct )
,       SchemaEntry("ifcsurfacestylewithtextures",&STEP::ObjectHelper<IfcSurfaceStyleWithTextures,1>::Construct )
,       SchemaEntry("ifcsweptdisksolid",&STEP::ObjectHelper<IfcSweptDiskSolid,5>::Construct )
,       SchemaEntry("ifcswitchingdevicetype",&STEP::ObjectHelper<IfcSwitchingDeviceType,1>::Construct )
,       SchemaEntry("ifcsymbolstyle",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcsystemfurnitureelementtype",&STEP::ObjectHelper<IfcSystemFurnitureElementType,0>::Construct )
,       SchemaEntry("ifctshapeprofiledef",&STEP::ObjectHelper<IfcTShapeProfileDef,10>::Construct )
,       SchemaEntry("ifctable",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctablerow",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctanktype",&STEP::ObjectHelper<IfcTankType,1>::Construct )
,       SchemaEntry("ifctelecomaddress",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctendon",&STEP::ObjectHelper<IfcTendon,8>::Construct )
,       SchemaEntry("ifctendonanchor",&STEP::ObjectHelper<IfcTendonAnchor,0>::Construct )
,       SchemaEntry("ifctextliteral",&STEP::ObjectHelper<IfcTextLiteral,3>::Construct )
,       SchemaEntry("ifctextliteralwithextent",&STEP::ObjectHelper<IfcTextLiteralWithExtent,2>::Construct )
,       SchemaEntry("ifctextstyle",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctextstylefontmodel",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctextstylefordefinedfont",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctextstyletextmodel",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctextstylewithboxcharacteristics",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctexturecoordinate",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctexturecoordinategenerator",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctexturemap",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctexturevertex",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcthermalmaterialproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctimeseriesreferencerelationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctimeseriesschedule",&STEP::ObjectHelper<IfcTimeSeriesSchedule,3>::Construct )
,       SchemaEntry("ifctimeseriesvalue",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifctopologyrepresentation",&STEP::ObjectHelper<IfcTopologyRepresentation,0>::Construct )
,       SchemaEntry("ifctransformertype",&STEP::ObjectHelper<IfcTransformerType,1>::Construct )
,       SchemaEntry("ifctransportelement",&STEP::ObjectHelper<IfcTransportElement,3>::Construct )
,       SchemaEntry("ifctransportelementtype",&STEP::ObjectHelper<IfcTransportElementType,1>::Construct )
,       SchemaEntry("ifctrapeziumprofiledef",&STEP::ObjectHelper<IfcTrapeziumProfileDef,4>::Construct )
,       SchemaEntry("ifctrimmedcurve",&STEP::ObjectHelper<IfcTrimmedCurve,5>::Construct )
,       SchemaEntry("ifctubebundletype",&STEP::ObjectHelper<IfcTubeBundleType,1>::Construct )
,       SchemaEntry("ifctwodirectionrepeatfactor",&STEP::ObjectHelper<IfcTwoDirectionRepeatFactor,1>::Construct )
,       SchemaEntry("ifcushapeprofiledef",&STEP::ObjectHelper<IfcUShapeProfileDef,8>::Construct )
,       SchemaEntry("ifcunitassignment",&STEP::ObjectHelper<IfcUnitAssignment,1>::Construct )
,       SchemaEntry("ifcunitaryequipmenttype",&STEP::ObjectHelper<IfcUnitaryEquipmentType,1>::Construct )
,       SchemaEntry("ifcvalvetype",&STEP::ObjectHelper<IfcValveType,1>::Construct )
,       SchemaEntry("ifcvector",&STEP::ObjectHelper<IfcVector,2>::Construct )
,       SchemaEntry("ifcvertex",&STEP::ObjectHelper<IfcVertex,0>::Construct )
,       SchemaEntry("ifcvertexbasedtexturemap",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcvertexloop",&STEP::ObjectHelper<IfcVertexLoop,1>::Construct )
,       SchemaEntry("ifcvertexpoint",&STEP::ObjectHelper<IfcVertexPoint,1>::Construct )
,       SchemaEntry("ifcvibrationisolatortype",&STEP::ObjectHelper<IfcVibrationIsolatorType,1>::Construct )
,       SchemaEntry("ifcvirtualelement",&STEP::ObjectHelper<IfcVirtualElement,0>::Construct )
,       SchemaEntry("ifcvirtualgridintersection",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcwall",&STEP::ObjectHelper<IfcWall,0>::Construct )
,       SchemaEntry("ifcwallstandardcase",&STEP::ObjectHelper<IfcWallStandardCase,0>::Construct )
,       SchemaEntry("ifcwalltype",&STEP::ObjectHelper<IfcWallType,1>::Construct )
,       SchemaEntry("ifcwasteterminaltype",&STEP::ObjectHelper<IfcWasteTerminalType,1>::Construct )
,       SchemaEntry("ifcwaterproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcwindow",&STEP::ObjectHelper<IfcWindow,2>::Construct )
,       SchemaEntry("ifcwindowliningproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcwindowpanelproperties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,       SchemaEntry("ifcwindowstyle",&STEP::ObjectHelper<IfcWindowStyle,4>::Construct )
,       SchemaEntry("ifcworkcontrol",&STEP::ObjectHelper<IfcWorkControl,10>::Construct )
,       SchemaEntry("ifcworkplan",&STEP::ObjectHelper<IfcWorkPlan,0>::Construct )
,       SchemaEntry("ifcworkschedule",&STEP::ObjectHelper<IfcWorkSchedule,0>::Construct )
,       SchemaEntry("ifczshapeprofiledef",&STEP::ObjectHelper<IfcZShapeProfileDef,6>::Construct )
,       SchemaEntry("ifczone",&STEP::ObjectHelper<IfcZone,0>::Construct )

    };
}

// -----------------------------------------------------------------------------------------------------------
void IFC::GetSchema(EXPRESS::ConversionSchema& out)
{
    out = EXPRESS::ConversionSchema(schema_raw);
}

namespace STEP {

// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<NotImplemented>(const STEP::DB& db, const LIST& params, NotImplemented* in)
{
    return 0;
}



// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRepresentationItem>(const DB& db, const LIST& params, IfcRepresentationItem* in)
{
    size_t base = 0;
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcGeometricRepresentationItem>(const DB& db, const LIST& params, IfcGeometricRepresentationItem* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRepresentationItem*>(in));
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCurve>(const DB& db, const LIST& params, IfcCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBoundedCurve>(const DB& db, const LIST& params, IfcBoundedCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCompositeCurve>(const DB& db, const LIST& params, IfcCompositeCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcCompositeCurve"); }    do { // convert the 'Segments' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurve,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Segments, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCompositeCurve to be a `LIST [1:?] OF IfcCompositeCurveSegment`")); }
    } while(0);
    do { // convert the 'SelfIntersect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCompositeCurve,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->SelfIntersect, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCompositeCurve to be a `LOGICAL`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<Ifc2DCompositeCurve>(const DB& db, const LIST& params, Ifc2DCompositeCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCompositeCurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRoot>(const DB& db, const LIST& params, IfcRoot* in)
{
    size_t base = 0;
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRoot"); }    do { // convert the 'GlobalId' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->GlobalId, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRoot to be a `IfcGloballyUniqueId`")); }
    } while(0);
    do { // convert the 'OwnerHistory' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->OwnerHistory, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRoot to be a `IfcOwnerHistory`")); }
    } while(0);
    do { // convert the 'Name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[2]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Name, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRoot to be a `IfcLabel`")); }
    } while(0);
    do { // convert the 'Description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRoot,4>::aux_is_derived[3]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Description, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRoot to be a `IfcText`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcObjectDefinition>(const DB& db, const LIST& params, IfcObjectDefinition* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRoot*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcObjectDefinition"); } return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcObject>(const DB& db, const LIST& params, IfcObject* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcObjectDefinition*>(in));
    if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcObject"); }    do { // convert the 'ObjectType' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcObject,1>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->ObjectType, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcObject to be a `IfcLabel`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcControl>(const DB& db, const LIST& params, IfcControl* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcObject*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcActionRequest>(const DB& db, const LIST& params, IfcActionRequest* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcActor>(const DB& db, const LIST& params, IfcActor* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcObject*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTypeObject>(const DB& db, const LIST& params, IfcTypeObject* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcObjectDefinition*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTypeProduct>(const DB& db, const LIST& params, IfcTypeProduct* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTypeObject*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElementType>(const DB& db, const LIST& params, IfcElementType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTypeProduct*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDistributionElementType>(const DB& db, const LIST& params, IfcDistributionElementType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDistributionControlElementType>(const DB& db, const LIST& params, IfcDistributionControlElementType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcActuatorType>(const DB& db, const LIST& params, IfcActuatorType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionControlElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDistributionFlowElementType>(const DB& db, const LIST& params, IfcDistributionFlowElementType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowControllerType>(const DB& db, const LIST& params, IfcFlowControllerType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAirTerminalBoxType>(const DB& db, const LIST& params, IfcAirTerminalBoxType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowControllerType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowTerminalType>(const DB& db, const LIST& params, IfcFlowTerminalType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAirTerminalType>(const DB& db, const LIST& params, IfcAirTerminalType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEnergyConversionDeviceType>(const DB& db, const LIST& params, IfcEnergyConversionDeviceType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAirToAirHeatRecoveryType>(const DB& db, const LIST& params, IfcAirToAirHeatRecoveryType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAlarmType>(const DB& db, const LIST& params, IfcAlarmType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionControlElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDraughtingCallout>(const DB& db, const LIST& params, IfcDraughtingCallout* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDimensionCurveDirectedCallout>(const DB& db, const LIST& params, IfcDimensionCurveDirectedCallout* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDraughtingCallout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAngularDimension>(const DB& db, const LIST& params, IfcAngularDimension* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDimensionCurveDirectedCallout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProduct>(const DB& db, const LIST& params, IfcProduct* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcObject*>(in));
    if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to IfcProduct"); }    do { // convert the 'ObjectPlacement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProduct,2>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->ObjectPlacement, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcProduct to be a `IfcObjectPlacement`")); }
    } while(0);
    do { // convert the 'Representation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProduct,2>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Representation, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcProduct to be a `IfcProductRepresentation`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAnnotation>(const DB& db, const LIST& params, IfcAnnotation* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
    if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to IfcAnnotation"); }   return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStyledItem>(const DB& db, const LIST& params, IfcStyledItem* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRepresentationItem*>(in));
    if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcStyledItem"); }    do { // convert the 'Item' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcStyledItem,3>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Item, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcStyledItem to be a `IfcRepresentationItem`")); }
    } while(0);
    do { // convert the 'Styles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcStyledItem,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->Styles, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcStyledItem to be a `SET [1:?] OF IfcPresentationStyleAssignment`")); }
    } while(0);
    do { // convert the 'Name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcStyledItem,3>::aux_is_derived[2]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Name, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcStyledItem to be a `IfcLabel`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAnnotationOccurrence>(const DB& db, const LIST& params, IfcAnnotationOccurrence* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStyledItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAnnotationCurveOccurrence>(const DB& db, const LIST& params, IfcAnnotationCurveOccurrence* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcAnnotationOccurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAnnotationFillArea>(const DB& db, const LIST& params, IfcAnnotationFillArea* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAnnotationFillAreaOccurrence>(const DB& db, const LIST& params, IfcAnnotationFillAreaOccurrence* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcAnnotationOccurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAnnotationSurface>(const DB& db, const LIST& params, IfcAnnotationSurface* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAnnotationSurfaceOccurrence>(const DB& db, const LIST& params, IfcAnnotationSurfaceOccurrence* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcAnnotationOccurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAnnotationSymbolOccurrence>(const DB& db, const LIST& params, IfcAnnotationSymbolOccurrence* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcAnnotationOccurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAnnotationTextOccurrence>(const DB& db, const LIST& params, IfcAnnotationTextOccurrence* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcAnnotationOccurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProfileDef>(const DB& db, const LIST& params, IfcProfileDef* in)
{
    size_t base = 0;
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcProfileDef"); }    do { // convert the 'ProfileType' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProfileDef,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->ProfileType, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProfileDef to be a `IfcProfileTypeEnum`")); }
    } while(0);
    do { // convert the 'ProfileName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProfileDef,2>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->ProfileName, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProfileDef to be a `IfcLabel`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcArbitraryClosedProfileDef>(const DB& db, const LIST& params, IfcArbitraryClosedProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
    if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcArbitraryClosedProfileDef"); }    do { // convert the 'OuterCurve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcArbitraryClosedProfileDef,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->OuterCurve, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcArbitraryClosedProfileDef to be a `IfcCurve`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcArbitraryOpenProfileDef>(const DB& db, const LIST& params, IfcArbitraryOpenProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
    if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcArbitraryOpenProfileDef"); }    do { // convert the 'Curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcArbitraryOpenProfileDef,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Curve, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcArbitraryOpenProfileDef to be a `IfcBoundedCurve`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcArbitraryProfileDefWithVoids>(const DB& db, const LIST& params, IfcArbitraryProfileDefWithVoids* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcArbitraryClosedProfileDef*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcArbitraryProfileDefWithVoids"); }    do { // convert the 'InnerCurves' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->InnerCurves, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcArbitraryProfileDefWithVoids to be a `SET [1:?] OF IfcCurve`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcGroup>(const DB& db, const LIST& params, IfcGroup* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcObject*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAsset>(const DB& db, const LIST& params, IfcAsset* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGroup*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcParameterizedProfileDef>(const DB& db, const LIST& params, IfcParameterizedProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
    if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcParameterizedProfileDef"); }    do { // convert the 'Position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcParameterizedProfileDef,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Position, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcParameterizedProfileDef to be a `IfcAxis2Placement2D`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcIShapeProfileDef>(const DB& db, const LIST& params, IfcIShapeProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
    if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to IfcIShapeProfileDef"); }    do { // convert the 'OverallWidth' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcIShapeProfileDef,5>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->OverallWidth, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    do { // convert the 'OverallDepth' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcIShapeProfileDef,5>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->OverallDepth, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    do { // convert the 'WebThickness' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcIShapeProfileDef,5>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->WebThickness, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    do { // convert the 'FlangeThickness' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcIShapeProfileDef,5>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->FlangeThickness, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    do { // convert the 'FilletRadius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcIShapeProfileDef,5>::aux_is_derived[4]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->FilletRadius, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcIShapeProfileDef to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAsymmetricIShapeProfileDef>(const DB& db, const LIST& params, IfcAsymmetricIShapeProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcIShapeProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPlacement>(const DB& db, const LIST& params, IfcPlacement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPlacement"); }    do { // convert the 'Location' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcPlacement,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Location, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPlacement to be a `IfcCartesianPoint`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAxis1Placement>(const DB& db, const LIST& params, IfcAxis1Placement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPlacement*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcAxis1Placement"); }    do { // convert the 'Axis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Axis, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis1Placement to be a `IfcDirection`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAxis2Placement2D>(const DB& db, const LIST& params, IfcAxis2Placement2D* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPlacement*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcAxis2Placement2D"); }    do { // convert the 'RefDirection' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->RefDirection, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis2Placement2D to be a `IfcDirection`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcAxis2Placement3D>(const DB& db, const LIST& params, IfcAxis2Placement3D* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPlacement*>(in));
    if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcAxis2Placement3D"); }    do { // convert the 'Axis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Axis, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcAxis2Placement3D to be a `IfcDirection`")); }
    } while(0);
    do { // convert the 'RefDirection' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->RefDirection, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcAxis2Placement3D to be a `IfcDirection`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBSplineCurve>(const DB& db, const LIST& params, IfcBSplineCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
    if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcBSplineCurve"); }    do { // convert the 'Degree' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Degree, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBSplineCurve to be a `INTEGER`")); }
    } while(0);
    do { // convert the 'ControlPointsList' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->ControlPointsList, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBSplineCurve to be a `LIST [2:?] OF IfcCartesianPoint`")); }
    } while(0);
    do { // convert the 'CurveForm' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->CurveForm, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBSplineCurve to be a `IfcBSplineCurveForm`")); }
    } while(0);
    do { // convert the 'ClosedCurve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->ClosedCurve, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcBSplineCurve to be a `LOGICAL`")); }
    } while(0);
    do { // convert the 'SelfIntersect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBSplineCurve,5>::aux_is_derived[4]=true; break; }
        try { GenericConvert( in->SelfIntersect, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcBSplineCurve to be a `LOGICAL`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElement>(const DB& db, const LIST& params, IfcElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
    if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to IfcElement"); }    do { // convert the 'Tag' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcElement,1>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Tag, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcElement to be a `IfcIdentifier`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBuildingElement>(const DB& db, const LIST& params, IfcBuildingElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
    if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to IfcBuildingElement"); }  return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBeam>(const DB& db, const LIST& params, IfcBeam* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBuildingElementType>(const DB& db, const LIST& params, IfcBuildingElementType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBeamType>(const DB& db, const LIST& params, IfcBeamType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBezierCurve>(const DB& db, const LIST& params, IfcBezierCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBSplineCurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCsgPrimitive3D>(const DB& db, const LIST& params, IfcCsgPrimitive3D* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBlock>(const DB& db, const LIST& params, IfcBlock* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCsgPrimitive3D*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBoilerType>(const DB& db, const LIST& params, IfcBoilerType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBooleanResult>(const DB& db, const LIST& params, IfcBooleanResult* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcBooleanResult"); }    do { // convert the 'Operator' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBooleanResult,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Operator, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBooleanResult to be a `IfcBooleanOperator`")); }
    } while(0);
    do { // convert the 'FirstOperand' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBooleanResult,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->FirstOperand, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBooleanResult to be a `IfcBooleanOperand`")); }
    } while(0);
    do { // convert the 'SecondOperand' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcBooleanResult,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->SecondOperand, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBooleanResult to be a `IfcBooleanOperand`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBooleanClippingResult>(const DB& db, const LIST& params, IfcBooleanClippingResult* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBooleanResult*>(in));
    if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcBooleanClippingResult"); }    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSurface>(const DB& db, const LIST& params, IfcSurface* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBoundedSurface>(const DB& db, const LIST& params, IfcBoundedSurface* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSurface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBoundingBox>(const DB& db, const LIST& params, IfcBoundingBox* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcBoundingBox"); }    do { // convert the 'Corner' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Corner, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcBoundingBox to be a `IfcCartesianPoint`")); }
    } while(0);
    do { // convert the 'XDim' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->XDim, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    do { // convert the 'YDim' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->YDim, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    do { // convert the 'ZDim' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ZDim, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcBoundingBox to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcHalfSpaceSolid>(const DB& db, const LIST& params, IfcHalfSpaceSolid* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcHalfSpaceSolid"); }    do { // convert the 'BaseSurface' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcHalfSpaceSolid,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->BaseSurface, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcHalfSpaceSolid to be a `IfcSurface`")); }
    } while(0);
    do { // convert the 'AgreementFlag' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcHalfSpaceSolid,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->AgreementFlag, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcHalfSpaceSolid to be a `BOOLEAN`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBoxedHalfSpace>(const DB& db, const LIST& params, IfcBoxedHalfSpace* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcHalfSpaceSolid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSpatialStructureElement>(const DB& db, const LIST& params, IfcSpatialStructureElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
    if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcSpatialStructureElement"); }    do { // convert the 'LongName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSpatialStructureElement,2>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->LongName, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcSpatialStructureElement to be a `IfcLabel`")); }
    } while(0);
    do { // convert the 'CompositionType' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSpatialStructureElement,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->CompositionType, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcSpatialStructureElement to be a `IfcElementCompositionEnum`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBuilding>(const DB& db, const LIST& params, IfcBuilding* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElement*>(in));
    if (params.GetSize() < 12) { throw STEP::TypeError("expected 12 arguments to IfcBuilding"); }    do { // convert the 'ElevationOfRefHeight' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->ElevationOfRefHeight, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcBuilding to be a `IfcLengthMeasure`")); }
    } while(0);
    do { // convert the 'ElevationOfTerrain' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->ElevationOfTerrain, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcBuilding to be a `IfcLengthMeasure`")); }
    } while(0);
    do { // convert the 'BuildingAddress' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->BuildingAddress, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcBuilding to be a `IfcPostalAddress`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBuildingElementComponent>(const DB& db, const LIST& params, IfcBuildingElementComponent* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBuildingElementPart>(const DB& db, const LIST& params, IfcBuildingElementPart* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementComponent*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBuildingElementProxy>(const DB& db, const LIST& params, IfcBuildingElementProxy* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBuildingElementProxyType>(const DB& db, const LIST& params, IfcBuildingElementProxyType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcBuildingStorey>(const DB& db, const LIST& params, IfcBuildingStorey* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCShapeProfileDef>(const DB& db, const LIST& params, IfcCShapeProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowFittingType>(const DB& db, const LIST& params, IfcFlowFittingType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCableCarrierFittingType>(const DB& db, const LIST& params, IfcCableCarrierFittingType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowFittingType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowSegmentType>(const DB& db, const LIST& params, IfcFlowSegmentType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCableCarrierSegmentType>(const DB& db, const LIST& params, IfcCableCarrierSegmentType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowSegmentType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCableSegmentType>(const DB& db, const LIST& params, IfcCableSegmentType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowSegmentType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPoint>(const DB& db, const LIST& params, IfcPoint* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCartesianPoint>(const DB& db, const LIST& params, IfcCartesianPoint* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPoint*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcCartesianPoint"); }    do { // convert the 'Coordinates' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Coordinates, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCartesianPoint to be a `LIST [1:3] OF IfcLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCartesianTransformationOperator>(const DB& db, const LIST& params, IfcCartesianTransformationOperator* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcCartesianTransformationOperator"); }    do { // convert the 'Axis1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Axis1, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCartesianTransformationOperator to be a `IfcDirection`")); }
    } while(0);
    do { // convert the 'Axis2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Axis2, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCartesianTransformationOperator to be a `IfcDirection`")); }
    } while(0);
    do { // convert the 'LocalOrigin' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->LocalOrigin, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcCartesianTransformationOperator to be a `IfcCartesianPoint`")); }
    } while(0);
    do { // convert the 'Scale' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator,4>::aux_is_derived[3]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Scale, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcCartesianTransformationOperator to be a `REAL`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCartesianTransformationOperator2D>(const DB& db, const LIST& params, IfcCartesianTransformationOperator2D* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCartesianTransformationOperator*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCartesianTransformationOperator2DnonUniform>(const DB& db, const LIST& params, IfcCartesianTransformationOperator2DnonUniform* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCartesianTransformationOperator2D*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCartesianTransformationOperator3D>(const DB& db, const LIST& params, IfcCartesianTransformationOperator3D* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCartesianTransformationOperator*>(in));
    if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcCartesianTransformationOperator3D"); }    do { // convert the 'Axis3' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCartesianTransformationOperator3D,1>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Axis3, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcCartesianTransformationOperator3D to be a `IfcDirection`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCartesianTransformationOperator3DnonUniform>(const DB& db, const LIST& params, IfcCartesianTransformationOperator3DnonUniform* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCartesianTransformationOperator3D*>(in));
    if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to IfcCartesianTransformationOperator3DnonUniform"); }    do { // convert the 'Scale2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Scale2, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcCartesianTransformationOperator3DnonUniform to be a `REAL`")); }
    } while(0);
    do { // convert the 'Scale3' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Scale3, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcCartesianTransformationOperator3DnonUniform to be a `REAL`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCenterLineProfileDef>(const DB& db, const LIST& params, IfcCenterLineProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcArbitraryOpenProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFeatureElement>(const DB& db, const LIST& params, IfcFeatureElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
    if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to IfcFeatureElement"); }   return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFeatureElementSubtraction>(const DB& db, const LIST& params, IfcFeatureElementSubtraction* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFeatureElement*>(in));
    if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to IfcFeatureElementSubtraction"); }    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEdgeFeature>(const DB& db, const LIST& params, IfcEdgeFeature* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFeatureElementSubtraction*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcChamferEdgeFeature>(const DB& db, const LIST& params, IfcChamferEdgeFeature* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEdgeFeature*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcChillerType>(const DB& db, const LIST& params, IfcChillerType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcConic>(const DB& db, const LIST& params, IfcConic* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcConic"); }    do { // convert the 'Position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcConic,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Position, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcConic to be a `IfcAxis2Placement`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCircle>(const DB& db, const LIST& params, IfcCircle* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcConic*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcCircle"); }    do { // convert the 'Radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Radius, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCircle to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCircleProfileDef>(const DB& db, const LIST& params, IfcCircleProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcCircleProfileDef"); }    do { // convert the 'Radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcCircleProfileDef,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Radius, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcCircleProfileDef to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCircleHollowProfileDef>(const DB& db, const LIST& params, IfcCircleHollowProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCircleProfileDef*>(in));
    if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcCircleHollowProfileDef"); }    do { // convert the 'WallThickness' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->WallThickness, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcCircleHollowProfileDef to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTopologicalRepresentationItem>(const DB& db, const LIST& params, IfcTopologicalRepresentationItem* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRepresentationItem*>(in));
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcConnectedFaceSet>(const DB& db, const LIST& params, IfcConnectedFaceSet* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcConnectedFaceSet"); }    do { // convert the 'CfsFaces' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcConnectedFaceSet,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->CfsFaces, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcConnectedFaceSet to be a `SET [1:?] OF IfcFace`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcClosedShell>(const DB& db, const LIST& params, IfcClosedShell* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcConnectedFaceSet*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcClosedShell"); }  return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCoilType>(const DB& db, const LIST& params, IfcCoilType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcColourSpecification>(const DB& db, const LIST& params, IfcColourSpecification* in)
{
    size_t base = 0;
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcColourSpecification"); }    do { // convert the 'Name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcColourSpecification,1>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Name, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcColourSpecification to be a `IfcLabel`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcColourRgb>(const DB& db, const LIST& params, IfcColourRgb* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcColourSpecification*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcColourRgb"); }    do { // convert the 'Red' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Red, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
    } while(0);
    do { // convert the 'Green' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Green, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
    } while(0);
    do { // convert the 'Blue' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Blue, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcColourRgb to be a `IfcNormalisedRatioMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcColumn>(const DB& db, const LIST& params, IfcColumn* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcColumnType>(const DB& db, const LIST& params, IfcColumnType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProperty>(const DB& db, const LIST& params, IfcProperty* in)
{
    size_t base = 0;
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcProperty"); }    do { // convert the 'Name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProperty,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Name, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProperty to be a `IfcIdentifier`")); }
    } while(0);
    do { // convert the 'Description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProperty,2>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Description, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProperty to be a `IfcText`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcComplexProperty>(const DB& db, const LIST& params, IfcComplexProperty* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProperty*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcComplexProperty"); }    do { // convert the 'UsageName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->UsageName, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcComplexProperty to be a `IfcIdentifier`")); }
    } while(0);
    do { // convert the 'HasProperties' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->HasProperties, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcComplexProperty to be a `SET [1:?] OF IfcProperty`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCompositeCurveSegment>(const DB& db, const LIST& params, IfcCompositeCurveSegment* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcCompositeCurveSegment"); }    do { // convert the 'Transition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Transition, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcCompositeCurveSegment to be a `IfcTransitionCode`")); }
    } while(0);
    do { // convert the 'SameSense' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->SameSense, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcCompositeCurveSegment to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'ParentCurve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ParentCurve, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcCompositeCurveSegment to be a `IfcCurve`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCompositeProfileDef>(const DB& db, const LIST& params, IfcCompositeProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowMovingDeviceType>(const DB& db, const LIST& params, IfcFlowMovingDeviceType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCompressorType>(const DB& db, const LIST& params, IfcCompressorType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowMovingDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCondenserType>(const DB& db, const LIST& params, IfcCondenserType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCondition>(const DB& db, const LIST& params, IfcCondition* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGroup*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcConditionCriterion>(const DB& db, const LIST& params, IfcConditionCriterion* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcResource>(const DB& db, const LIST& params, IfcResource* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcObject*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcConstructionResource>(const DB& db, const LIST& params, IfcConstructionResource* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcResource*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcConstructionEquipmentResource>(const DB& db, const LIST& params, IfcConstructionEquipmentResource* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcConstructionResource*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcConstructionMaterialResource>(const DB& db, const LIST& params, IfcConstructionMaterialResource* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcConstructionResource*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcConstructionProductResource>(const DB& db, const LIST& params, IfcConstructionProductResource* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcConstructionResource*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcNamedUnit>(const DB& db, const LIST& params, IfcNamedUnit* in)
{
    size_t base = 0;
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcNamedUnit"); }    do { // convert the 'Dimensions' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcNamedUnit,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Dimensions, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcNamedUnit to be a `IfcDimensionalExponents`")); }
    } while(0);
    do { // convert the 'UnitType' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcNamedUnit,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->UnitType, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcNamedUnit to be a `IfcUnitEnum`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcContextDependentUnit>(const DB& db, const LIST& params, IfcContextDependentUnit* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcNamedUnit*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcControllerType>(const DB& db, const LIST& params, IfcControllerType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionControlElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcConversionBasedUnit>(const DB& db, const LIST& params, IfcConversionBasedUnit* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcNamedUnit*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcConversionBasedUnit"); }    do { // convert the 'Name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Name, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcConversionBasedUnit to be a `IfcLabel`")); }
    } while(0);
    do { // convert the 'ConversionFactor' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ConversionFactor, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcConversionBasedUnit to be a `IfcMeasureWithUnit`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCooledBeamType>(const DB& db, const LIST& params, IfcCooledBeamType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCoolingTowerType>(const DB& db, const LIST& params, IfcCoolingTowerType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCostItem>(const DB& db, const LIST& params, IfcCostItem* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCostSchedule>(const DB& db, const LIST& params, IfcCostSchedule* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCovering>(const DB& db, const LIST& params, IfcCovering* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCoveringType>(const DB& db, const LIST& params, IfcCoveringType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCraneRailAShapeProfileDef>(const DB& db, const LIST& params, IfcCraneRailAShapeProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCraneRailFShapeProfileDef>(const DB& db, const LIST& params, IfcCraneRailFShapeProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCrewResource>(const DB& db, const LIST& params, IfcCrewResource* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcConstructionResource*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSolidModel>(const DB& db, const LIST& params, IfcSolidModel* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCsgSolid>(const DB& db, const LIST& params, IfcCsgSolid* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSolidModel*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCurtainWall>(const DB& db, const LIST& params, IfcCurtainWall* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCurtainWallType>(const DB& db, const LIST& params, IfcCurtainWallType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcCurveBoundedPlane>(const DB& db, const LIST& params, IfcCurveBoundedPlane* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBoundedSurface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPresentationStyle>(const DB& db, const LIST& params, IfcPresentationStyle* in)
{
    size_t base = 0;
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPresentationStyle"); }    do { // convert the 'Name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcPresentationStyle,1>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Name, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPresentationStyle to be a `IfcLabel`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDamperType>(const DB& db, const LIST& params, IfcDamperType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowControllerType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDefinedSymbol>(const DB& db, const LIST& params, IfcDefinedSymbol* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDerivedProfileDef>(const DB& db, const LIST& params, IfcDerivedProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDiameterDimension>(const DB& db, const LIST& params, IfcDiameterDimension* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDimensionCurveDirectedCallout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDimensionCurve>(const DB& db, const LIST& params, IfcDimensionCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcAnnotationCurveOccurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTerminatorSymbol>(const DB& db, const LIST& params, IfcTerminatorSymbol* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcAnnotationSymbolOccurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDimensionCurveTerminator>(const DB& db, const LIST& params, IfcDimensionCurveTerminator* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTerminatorSymbol*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDirection>(const DB& db, const LIST& params, IfcDirection* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcDirection"); }    do { // convert the 'DirectionRatios' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->DirectionRatios, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcDirection to be a `LIST [2:3] OF REAL`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElementComponent>(const DB& db, const LIST& params, IfcElementComponent* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDiscreteAccessory>(const DB& db, const LIST& params, IfcDiscreteAccessory* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElementComponent*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElementComponentType>(const DB& db, const LIST& params, IfcElementComponentType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDiscreteAccessoryType>(const DB& db, const LIST& params, IfcDiscreteAccessoryType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElementComponentType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDistributionElement>(const DB& db, const LIST& params, IfcDistributionElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDistributionFlowElement>(const DB& db, const LIST& params, IfcDistributionFlowElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDistributionChamberElement>(const DB& db, const LIST& params, IfcDistributionChamberElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDistributionChamberElementType>(const DB& db, const LIST& params, IfcDistributionChamberElementType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDistributionControlElement>(const DB& db, const LIST& params, IfcDistributionControlElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPort>(const DB& db, const LIST& params, IfcPort* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDistributionPort>(const DB& db, const LIST& params, IfcDistributionPort* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPort*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDoor>(const DB& db, const LIST& params, IfcDoor* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
    if (params.GetSize() < 10) { throw STEP::TypeError("expected 10 arguments to IfcDoor"); }    do { // convert the 'OverallHeight' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->OverallHeight, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcDoor to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    do { // convert the 'OverallWidth' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->OverallWidth, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcDoor to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPropertyDefinition>(const DB& db, const LIST& params, IfcPropertyDefinition* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRoot*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertyDefinition"); }   return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPropertySetDefinition>(const DB& db, const LIST& params, IfcPropertySetDefinition* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPropertyDefinition*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertySetDefinition"); }    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDoorStyle>(const DB& db, const LIST& params, IfcDoorStyle* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTypeProduct*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDuctFittingType>(const DB& db, const LIST& params, IfcDuctFittingType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowFittingType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDuctSegmentType>(const DB& db, const LIST& params, IfcDuctSegmentType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowSegmentType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowTreatmentDeviceType>(const DB& db, const LIST& params, IfcFlowTreatmentDeviceType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcDuctSilencerType>(const DB& db, const LIST& params, IfcDuctSilencerType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTreatmentDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEdge>(const DB& db, const LIST& params, IfcEdge* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEdgeCurve>(const DB& db, const LIST& params, IfcEdgeCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEdge*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLoop>(const DB& db, const LIST& params, IfcLoop* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEdgeLoop>(const DB& db, const LIST& params, IfcEdgeLoop* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcLoop*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElectricApplianceType>(const DB& db, const LIST& params, IfcElectricApplianceType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowController>(const DB& db, const LIST& params, IfcFlowController* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElectricDistributionPoint>(const DB& db, const LIST& params, IfcElectricDistributionPoint* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowController*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowStorageDeviceType>(const DB& db, const LIST& params, IfcFlowStorageDeviceType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElectricFlowStorageDeviceType>(const DB& db, const LIST& params, IfcElectricFlowStorageDeviceType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowStorageDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElectricGeneratorType>(const DB& db, const LIST& params, IfcElectricGeneratorType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElectricHeaterType>(const DB& db, const LIST& params, IfcElectricHeaterType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElectricMotorType>(const DB& db, const LIST& params, IfcElectricMotorType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElectricTimeControlType>(const DB& db, const LIST& params, IfcElectricTimeControlType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowControllerType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSystem>(const DB& db, const LIST& params, IfcSystem* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGroup*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElectricalCircuit>(const DB& db, const LIST& params, IfcElectricalCircuit* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSystem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElectricalElement>(const DB& db, const LIST& params, IfcElectricalElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElementAssembly>(const DB& db, const LIST& params, IfcElementAssembly* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElementQuantity>(const DB& db, const LIST& params, IfcElementQuantity* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPropertySetDefinition*>(in));
    if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcElementQuantity"); }    do { // convert the 'MethodOfMeasurement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->MethodOfMeasurement, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcElementQuantity to be a `IfcLabel`")); }
    } while(0);
    do { // convert the 'Quantities' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Quantities, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcElementQuantity to be a `SET [1:?] OF IfcPhysicalQuantity`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcElementarySurface>(const DB& db, const LIST& params, IfcElementarySurface* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSurface*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcElementarySurface"); }    do { // convert the 'Position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcElementarySurface,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Position, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcElementarySurface to be a `IfcAxis2Placement3D`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEllipse>(const DB& db, const LIST& params, IfcEllipse* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcConic*>(in));
    if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcEllipse"); }    do { // convert the 'SemiAxis1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->SemiAxis1, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcEllipse to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    do { // convert the 'SemiAxis2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->SemiAxis2, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcEllipse to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEllipseProfileDef>(const DB& db, const LIST& params, IfcEllipseProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEnergyConversionDevice>(const DB& db, const LIST& params, IfcEnergyConversionDevice* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEquipmentElement>(const DB& db, const LIST& params, IfcEquipmentElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEquipmentStandard>(const DB& db, const LIST& params, IfcEquipmentStandard* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEvaporativeCoolerType>(const DB& db, const LIST& params, IfcEvaporativeCoolerType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcEvaporatorType>(const DB& db, const LIST& params, IfcEvaporatorType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSweptAreaSolid>(const DB& db, const LIST& params, IfcSweptAreaSolid* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSolidModel*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcSweptAreaSolid"); }    do { // convert the 'SweptArea' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptAreaSolid,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->SweptArea, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSweptAreaSolid to be a `IfcProfileDef`")); }
    } while(0);
    do { // convert the 'Position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSweptAreaSolid,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->Position, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSweptAreaSolid to be a `IfcAxis2Placement3D`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcExtrudedAreaSolid>(const DB& db, const LIST& params, IfcExtrudedAreaSolid* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSweptAreaSolid*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcExtrudedAreaSolid"); }    do { // convert the 'ExtrudedDirection' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ExtrudedDirection, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcExtrudedAreaSolid to be a `IfcDirection`")); }
    } while(0);
    do { // convert the 'Depth' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Depth, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcExtrudedAreaSolid to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFace>(const DB& db, const LIST& params, IfcFace* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcFace"); }    do { // convert the 'Bounds' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcFace,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Bounds, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFace to be a `SET [1:?] OF IfcFaceBound`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFaceBasedSurfaceModel>(const DB& db, const LIST& params, IfcFaceBasedSurfaceModel* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcFaceBasedSurfaceModel"); }    do { // convert the 'FbsmFaces' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->FbsmFaces, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFaceBasedSurfaceModel to be a `SET [1:?] OF IfcConnectedFaceSet`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFaceBound>(const DB& db, const LIST& params, IfcFaceBound* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcFaceBound"); }    do { // convert the 'Bound' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcFaceBound,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Bound, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcFaceBound to be a `IfcLoop`")); }
    } while(0);
    do { // convert the 'Orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcFaceBound,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->Orientation, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcFaceBound to be a `BOOLEAN`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFaceOuterBound>(const DB& db, const LIST& params, IfcFaceOuterBound* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFaceBound*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcFaceOuterBound"); }   return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFaceSurface>(const DB& db, const LIST& params, IfcFaceSurface* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFace*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcManifoldSolidBrep>(const DB& db, const LIST& params, IfcManifoldSolidBrep* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSolidModel*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcManifoldSolidBrep"); }    do { // convert the 'Outer' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcManifoldSolidBrep,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->Outer, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcManifoldSolidBrep to be a `IfcClosedShell`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFacetedBrep>(const DB& db, const LIST& params, IfcFacetedBrep* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcManifoldSolidBrep*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFacetedBrepWithVoids>(const DB& db, const LIST& params, IfcFacetedBrepWithVoids* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcManifoldSolidBrep*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFanType>(const DB& db, const LIST& params, IfcFanType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowMovingDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFastener>(const DB& db, const LIST& params, IfcFastener* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElementComponent*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFastenerType>(const DB& db, const LIST& params, IfcFastenerType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElementComponentType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFeatureElementAddition>(const DB& db, const LIST& params, IfcFeatureElementAddition* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFeatureElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFillAreaStyleHatching>(const DB& db, const LIST& params, IfcFillAreaStyleHatching* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFillAreaStyleTileSymbolWithStyle>(const DB& db, const LIST& params, IfcFillAreaStyleTileSymbolWithStyle* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFillAreaStyleTiles>(const DB& db, const LIST& params, IfcFillAreaStyleTiles* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFilterType>(const DB& db, const LIST& params, IfcFilterType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTreatmentDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFireSuppressionTerminalType>(const DB& db, const LIST& params, IfcFireSuppressionTerminalType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowFitting>(const DB& db, const LIST& params, IfcFlowFitting* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowInstrumentType>(const DB& db, const LIST& params, IfcFlowInstrumentType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionControlElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowMeterType>(const DB& db, const LIST& params, IfcFlowMeterType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowControllerType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowMovingDevice>(const DB& db, const LIST& params, IfcFlowMovingDevice* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowSegment>(const DB& db, const LIST& params, IfcFlowSegment* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowStorageDevice>(const DB& db, const LIST& params, IfcFlowStorageDevice* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowTerminal>(const DB& db, const LIST& params, IfcFlowTerminal* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFlowTreatmentDevice>(const DB& db, const LIST& params, IfcFlowTreatmentDevice* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionFlowElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFooting>(const DB& db, const LIST& params, IfcFooting* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFurnishingElement>(const DB& db, const LIST& params, IfcFurnishingElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFurnishingElementType>(const DB& db, const LIST& params, IfcFurnishingElementType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFurnitureStandard>(const DB& db, const LIST& params, IfcFurnitureStandard* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcFurnitureType>(const DB& db, const LIST& params, IfcFurnitureType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFurnishingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcGasTerminalType>(const DB& db, const LIST& params, IfcGasTerminalType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcGeometricSet>(const DB& db, const LIST& params, IfcGeometricSet* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcGeometricCurveSet>(const DB& db, const LIST& params, IfcGeometricCurveSet* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricSet*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRepresentationContext>(const DB& db, const LIST& params, IfcRepresentationContext* in)
{
    size_t base = 0;
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcRepresentationContext"); }    do { // convert the 'ContextIdentifier' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentationContext,2>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->ContextIdentifier, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentationContext to be a `IfcLabel`")); }
    } while(0);
    do { // convert the 'ContextType' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentationContext,2>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->ContextType, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentationContext to be a `IfcLabel`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcGeometricRepresentationContext>(const DB& db, const LIST& params, IfcGeometricRepresentationContext* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRepresentationContext*>(in));
    if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcGeometricRepresentationContext"); }    do { // convert the 'CoordinateSpaceDimension' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->CoordinateSpaceDimension, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcGeometricRepresentationContext to be a `IfcDimensionCount`")); }
    } while(0);
    do { // convert the 'Precision' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Precision, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcGeometricRepresentationContext to be a `REAL`")); }
    } while(0);
    do { // convert the 'WorldCoordinateSystem' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->WorldCoordinateSystem, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcGeometricRepresentationContext to be a `IfcAxis2Placement`")); }
    } while(0);
    do { // convert the 'TrueNorth' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcGeometricRepresentationContext,4>::aux_is_derived[3]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->TrueNorth, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcGeometricRepresentationContext to be a `IfcDirection`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcGeometricRepresentationSubContext>(const DB& db, const LIST& params, IfcGeometricRepresentationSubContext* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationContext*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcGrid>(const DB& db, const LIST& params, IfcGrid* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcObjectPlacement>(const DB& db, const LIST& params, IfcObjectPlacement* in)
{
    size_t base = 0;
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcGridPlacement>(const DB& db, const LIST& params, IfcGridPlacement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcObjectPlacement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcHeatExchangerType>(const DB& db, const LIST& params, IfcHeatExchangerType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcHumidifierType>(const DB& db, const LIST& params, IfcHumidifierType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcInventory>(const DB& db, const LIST& params, IfcInventory* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGroup*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcJunctionBoxType>(const DB& db, const LIST& params, IfcJunctionBoxType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowFittingType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLShapeProfileDef>(const DB& db, const LIST& params, IfcLShapeProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLaborResource>(const DB& db, const LIST& params, IfcLaborResource* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcConstructionResource*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLampType>(const DB& db, const LIST& params, IfcLampType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLightFixtureType>(const DB& db, const LIST& params, IfcLightFixtureType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLightSource>(const DB& db, const LIST& params, IfcLightSource* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLightSourceAmbient>(const DB& db, const LIST& params, IfcLightSourceAmbient* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcLightSource*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLightSourceDirectional>(const DB& db, const LIST& params, IfcLightSourceDirectional* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcLightSource*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLightSourceGoniometric>(const DB& db, const LIST& params, IfcLightSourceGoniometric* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcLightSource*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLightSourcePositional>(const DB& db, const LIST& params, IfcLightSourcePositional* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcLightSource*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLightSourceSpot>(const DB& db, const LIST& params, IfcLightSourceSpot* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcLightSourcePositional*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLine>(const DB& db, const LIST& params, IfcLine* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcLine"); }    do { // convert the 'Pnt' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Pnt, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcLine to be a `IfcCartesianPoint`")); }
    } while(0);
    do { // convert the 'Dir' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Dir, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcLine to be a `IfcVector`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLinearDimension>(const DB& db, const LIST& params, IfcLinearDimension* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDimensionCurveDirectedCallout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcLocalPlacement>(const DB& db, const LIST& params, IfcLocalPlacement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcObjectPlacement*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcLocalPlacement"); }    do { // convert the 'PlacementRelTo' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->PlacementRelTo, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcLocalPlacement to be a `IfcObjectPlacement`")); }
    } while(0);
    do { // convert the 'RelativePlacement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->RelativePlacement, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcLocalPlacement to be a `IfcAxis2Placement`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcMappedItem>(const DB& db, const LIST& params, IfcMappedItem* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRepresentationItem*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcMappedItem"); }    do { // convert the 'MappingSource' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->MappingSource, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcMappedItem to be a `IfcRepresentationMap`")); }
    } while(0);
    do { // convert the 'MappingTarget' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->MappingTarget, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcMappedItem to be a `IfcCartesianTransformationOperator`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProductRepresentation>(const DB& db, const LIST& params, IfcProductRepresentation* in)
{
    size_t base = 0;
    if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcProductRepresentation"); }    do { // convert the 'Name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProductRepresentation,3>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Name, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcProductRepresentation to be a `IfcLabel`")); }
    } while(0);
    do { // convert the 'Description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProductRepresentation,3>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Description, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcProductRepresentation to be a `IfcText`")); }
    } while(0);
    do { // convert the 'Representations' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcProductRepresentation,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->Representations, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcProductRepresentation to be a `LIST [1:?] OF IfcRepresentation`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcMaterialDefinitionRepresentation>(const DB& db, const LIST& params, IfcMaterialDefinitionRepresentation* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProductRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcMeasureWithUnit>(const DB& db, const LIST& params, IfcMeasureWithUnit* in)
{
    size_t base = 0;
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcMeasureWithUnit"); }    do { // convert the 'ValueComponent' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ValueComponent, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcMeasureWithUnit to be a `IfcValue`")); }
    } while(0);
    do { // convert the 'UnitComponent' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->UnitComponent, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcMeasureWithUnit to be a `IfcUnit`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcMechanicalFastener>(const DB& db, const LIST& params, IfcMechanicalFastener* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFastener*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcMechanicalFastenerType>(const DB& db, const LIST& params, IfcMechanicalFastenerType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFastenerType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcMember>(const DB& db, const LIST& params, IfcMember* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcMemberType>(const DB& db, const LIST& params, IfcMemberType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcMotorConnectionType>(const DB& db, const LIST& params, IfcMotorConnectionType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProcess>(const DB& db, const LIST& params, IfcProcess* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcObject*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTask>(const DB& db, const LIST& params, IfcTask* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProcess*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcMove>(const DB& db, const LIST& params, IfcMove* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTask*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcOccupant>(const DB& db, const LIST& params, IfcOccupant* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcActor*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcOffsetCurve2D>(const DB& db, const LIST& params, IfcOffsetCurve2D* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcOffsetCurve3D>(const DB& db, const LIST& params, IfcOffsetCurve3D* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcOneDirectionRepeatFactor>(const DB& db, const LIST& params, IfcOneDirectionRepeatFactor* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcOpenShell>(const DB& db, const LIST& params, IfcOpenShell* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcConnectedFaceSet*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcOpeningElement>(const DB& db, const LIST& params, IfcOpeningElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFeatureElementSubtraction*>(in));
    if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to IfcOpeningElement"); }   return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcOrderAction>(const DB& db, const LIST& params, IfcOrderAction* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTask*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcOrientedEdge>(const DB& db, const LIST& params, IfcOrientedEdge* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEdge*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcOutletType>(const DB& db, const LIST& params, IfcOutletType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPath>(const DB& db, const LIST& params, IfcPath* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPerformanceHistory>(const DB& db, const LIST& params, IfcPerformanceHistory* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPermit>(const DB& db, const LIST& params, IfcPermit* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPile>(const DB& db, const LIST& params, IfcPile* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPipeFittingType>(const DB& db, const LIST& params, IfcPipeFittingType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowFittingType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPipeSegmentType>(const DB& db, const LIST& params, IfcPipeSegmentType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowSegmentType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPlanarExtent>(const DB& db, const LIST& params, IfcPlanarExtent* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPlanarBox>(const DB& db, const LIST& params, IfcPlanarBox* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPlanarExtent*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPlane>(const DB& db, const LIST& params, IfcPlane* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElementarySurface*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPlane"); }    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPlate>(const DB& db, const LIST& params, IfcPlate* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPlateType>(const DB& db, const LIST& params, IfcPlateType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPointOnCurve>(const DB& db, const LIST& params, IfcPointOnCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPoint*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPointOnSurface>(const DB& db, const LIST& params, IfcPointOnSurface* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPoint*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPolyLoop>(const DB& db, const LIST& params, IfcPolyLoop* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcLoop*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPolyLoop"); }    do { // convert the 'Polygon' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Polygon, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPolyLoop to be a `LIST [3:?] OF IfcCartesianPoint`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPolygonalBoundedHalfSpace>(const DB& db, const LIST& params, IfcPolygonalBoundedHalfSpace* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcHalfSpaceSolid*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPolygonalBoundedHalfSpace"); }    do { // convert the 'Position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Position, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPolygonalBoundedHalfSpace to be a `IfcAxis2Placement3D`")); }
    } while(0);
    do { // convert the 'PolygonalBoundary' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->PolygonalBoundary, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPolygonalBoundedHalfSpace to be a `IfcBoundedCurve`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPolyline>(const DB& db, const LIST& params, IfcPolyline* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPolyline"); }    do { // convert the 'Points' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Points, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPolyline to be a `LIST [2:?] OF IfcCartesianPoint`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPresentationStyleAssignment>(const DB& db, const LIST& params, IfcPresentationStyleAssignment* in)
{
    size_t base = 0;
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcPresentationStyleAssignment"); }    do { // convert the 'Styles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Styles, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcPresentationStyleAssignment to be a `SET [1:?] OF IfcPresentationStyleSelect`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProcedure>(const DB& db, const LIST& params, IfcProcedure* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProcess*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProductDefinitionShape>(const DB& db, const LIST& params, IfcProductDefinitionShape* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProductRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProject>(const DB& db, const LIST& params, IfcProject* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcObject*>(in));
    if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcProject"); }    do { // convert the 'LongName' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->LongName, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcProject to be a `IfcLabel`")); }
    } while(0);
    do { // convert the 'Phase' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Phase, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcProject to be a `IfcLabel`")); }
    } while(0);
    do { // convert the 'RepresentationContexts' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->RepresentationContexts, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcProject to be a `SET [1:?] OF IfcRepresentationContext`")); }
    } while(0);
    do { // convert the 'UnitsInContext' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->UnitsInContext, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcProject to be a `IfcUnitAssignment`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProjectOrder>(const DB& db, const LIST& params, IfcProjectOrder* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProjectOrderRecord>(const DB& db, const LIST& params, IfcProjectOrderRecord* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProjectionCurve>(const DB& db, const LIST& params, IfcProjectionCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcAnnotationCurveOccurrence*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProjectionElement>(const DB& db, const LIST& params, IfcProjectionElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFeatureElementAddition*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSimpleProperty>(const DB& db, const LIST& params, IfcSimpleProperty* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProperty*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcSimpleProperty"); }   return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPropertyBoundedValue>(const DB& db, const LIST& params, IfcPropertyBoundedValue* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPropertyEnumeratedValue>(const DB& db, const LIST& params, IfcPropertyEnumeratedValue* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPropertyListValue>(const DB& db, const LIST& params, IfcPropertyListValue* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertyListValue"); }    do { // convert the 'ListValues' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ListValues, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPropertyListValue to be a `LIST [1:?] OF IfcValue`")); }
    } while(0);
    do { // convert the 'Unit' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Unit, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPropertyListValue to be a `IfcUnit`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPropertyReferenceValue>(const DB& db, const LIST& params, IfcPropertyReferenceValue* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPropertySet>(const DB& db, const LIST& params, IfcPropertySet* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPropertySetDefinition*>(in));
    if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcPropertySet"); }    do { // convert the 'HasProperties' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->HasProperties, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcPropertySet to be a `SET [1:?] OF IfcProperty`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPropertySingleValue>(const DB& db, const LIST& params, IfcPropertySingleValue* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcPropertySingleValue"); }    do { // convert the 'NominalValue' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->NominalValue, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcPropertySingleValue to be a `IfcValue`")); }
    } while(0);
    do { // convert the 'Unit' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Unit, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcPropertySingleValue to be a `IfcUnit`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPropertyTableValue>(const DB& db, const LIST& params, IfcPropertyTableValue* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSimpleProperty*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProtectiveDeviceType>(const DB& db, const LIST& params, IfcProtectiveDeviceType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowControllerType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcProxy>(const DB& db, const LIST& params, IfcProxy* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcPumpType>(const DB& db, const LIST& params, IfcPumpType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowMovingDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRadiusDimension>(const DB& db, const LIST& params, IfcRadiusDimension* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDimensionCurveDirectedCallout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRailing>(const DB& db, const LIST& params, IfcRailing* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRailingType>(const DB& db, const LIST& params, IfcRailingType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRamp>(const DB& db, const LIST& params, IfcRamp* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRampFlight>(const DB& db, const LIST& params, IfcRampFlight* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRampFlightType>(const DB& db, const LIST& params, IfcRampFlightType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRationalBezierCurve>(const DB& db, const LIST& params, IfcRationalBezierCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBezierCurve*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRectangleProfileDef>(const DB& db, const LIST& params, IfcRectangleProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
    if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcRectangleProfileDef"); }    do { // convert the 'XDim' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRectangleProfileDef,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->XDim, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRectangleProfileDef to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    do { // convert the 'YDim' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRectangleProfileDef,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->YDim, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRectangleProfileDef to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRectangleHollowProfileDef>(const DB& db, const LIST& params, IfcRectangleHollowProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRectangleProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRectangularPyramid>(const DB& db, const LIST& params, IfcRectangularPyramid* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCsgPrimitive3D*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRectangularTrimmedSurface>(const DB& db, const LIST& params, IfcRectangularTrimmedSurface* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBoundedSurface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcReinforcingElement>(const DB& db, const LIST& params, IfcReinforcingElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementComponent*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcReinforcingBar>(const DB& db, const LIST& params, IfcReinforcingBar* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcReinforcingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcReinforcingMesh>(const DB& db, const LIST& params, IfcReinforcingMesh* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcReinforcingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRelationship>(const DB& db, const LIST& params, IfcRelationship* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRoot*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRelationship"); } return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRelDecomposes>(const DB& db, const LIST& params, IfcRelDecomposes* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRelationship*>(in));
    if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelDecomposes"); }    do { // convert the 'RelatingObject' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRelDecomposes,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->RelatingObject, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelDecomposes to be a `IfcObjectDefinition`")); }
    } while(0);
    do { // convert the 'RelatedObjects' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRelDecomposes,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->RelatedObjects, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelDecomposes to be a `SET [1:?] OF IfcObjectDefinition`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRelAggregates>(const DB& db, const LIST& params, IfcRelAggregates* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRelDecomposes*>(in));
    if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelAggregates"); }    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRelConnects>(const DB& db, const LIST& params, IfcRelConnects* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRelationship*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRelConnects"); }  return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRelContainedInSpatialStructure>(const DB& db, const LIST& params, IfcRelContainedInSpatialStructure* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
    if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelContainedInSpatialStructure"); }    do { // convert the 'RelatedElements' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->RelatedElements, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelContainedInSpatialStructure to be a `SET [1:?] OF IfcProduct`")); }
    } while(0);
    do { // convert the 'RelatingStructure' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->RelatingStructure, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelContainedInSpatialStructure to be a `IfcSpatialStructureElement`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRelDefines>(const DB& db, const LIST& params, IfcRelDefines* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRelationship*>(in));
    if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcRelDefines"); }    do { // convert the 'RelatedObjects' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRelDefines,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->RelatedObjects, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelDefines to be a `SET [1:?] OF IfcObject`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRelDefinesByProperties>(const DB& db, const LIST& params, IfcRelDefinesByProperties* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRelDefines*>(in));
    if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelDefinesByProperties"); }    do { // convert the 'RelatingPropertyDefinition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRelDefinesByProperties,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->RelatingPropertyDefinition, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelDefinesByProperties to be a `IfcPropertySetDefinition`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRelFillsElement>(const DB& db, const LIST& params, IfcRelFillsElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
    if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelFillsElement"); }    do { // convert the 'RelatingOpeningElement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->RelatingOpeningElement, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelFillsElement to be a `IfcOpeningElement`")); }
    } while(0);
    do { // convert the 'RelatedBuildingElement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->RelatedBuildingElement, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelFillsElement to be a `IfcElement`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRelOverridesProperties>(const DB& db, const LIST& params, IfcRelOverridesProperties* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRelDefinesByProperties*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRelVoidsElement>(const DB& db, const LIST& params, IfcRelVoidsElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRelConnects*>(in));
    if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to IfcRelVoidsElement"); }    do { // convert the 'RelatingBuildingElement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->RelatingBuildingElement, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcRelVoidsElement to be a `IfcElement`")); }
    } while(0);
    do { // convert the 'RelatedOpeningElement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->RelatedOpeningElement, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcRelVoidsElement to be a `IfcFeatureElementSubtraction`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRepresentation>(const DB& db, const LIST& params, IfcRepresentation* in)
{
    size_t base = 0;
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRepresentation"); }    do { // convert the 'ContextOfItems' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->ContextOfItems, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentation to be a `IfcRepresentationContext`")); }
    } while(0);
    do { // convert the 'RepresentationIdentifier' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->RepresentationIdentifier, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentation to be a `IfcLabel`")); }
    } while(0);
    do { // convert the 'RepresentationType' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[2]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->RepresentationType, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRepresentation to be a `IfcLabel`")); }
    } while(0);
    do { // convert the 'Items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcRepresentation,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->Items, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRepresentation to be a `SET [1:?] OF IfcRepresentationItem`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRepresentationMap>(const DB& db, const LIST& params, IfcRepresentationMap* in)
{
    size_t base = 0;
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcRepresentationMap"); }    do { // convert the 'MappingOrigin' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->MappingOrigin, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcRepresentationMap to be a `IfcAxis2Placement`")); }
    } while(0);
    do { // convert the 'MappedRepresentation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->MappedRepresentation, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcRepresentationMap to be a `IfcRepresentation`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRevolvedAreaSolid>(const DB& db, const LIST& params, IfcRevolvedAreaSolid* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSweptAreaSolid*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcRevolvedAreaSolid"); }    do { // convert the 'Axis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Axis, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcRevolvedAreaSolid to be a `IfcAxis1Placement`")); }
    } while(0);
    do { // convert the 'Angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Angle, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcRevolvedAreaSolid to be a `IfcPlaneAngleMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRightCircularCone>(const DB& db, const LIST& params, IfcRightCircularCone* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCsgPrimitive3D*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRightCircularCylinder>(const DB& db, const LIST& params, IfcRightCircularCylinder* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCsgPrimitive3D*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRoof>(const DB& db, const LIST& params, IfcRoof* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRoundedEdgeFeature>(const DB& db, const LIST& params, IfcRoundedEdgeFeature* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEdgeFeature*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcRoundedRectangleProfileDef>(const DB& db, const LIST& params, IfcRoundedRectangleProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRectangleProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSIUnit>(const DB& db, const LIST& params, IfcSIUnit* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcNamedUnit*>(in));
    if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to IfcSIUnit"); }    do { // convert the 'Prefix' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Prefix, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSIUnit to be a `IfcSIPrefix`")); }
    } while(0);
    do { // convert the 'Name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Name, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSIUnit to be a `IfcSIUnitName`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSanitaryTerminalType>(const DB& db, const LIST& params, IfcSanitaryTerminalType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcScheduleTimeControl>(const DB& db, const LIST& params, IfcScheduleTimeControl* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSectionedSpine>(const DB& db, const LIST& params, IfcSectionedSpine* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSensorType>(const DB& db, const LIST& params, IfcSensorType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDistributionControlElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcServiceLife>(const DB& db, const LIST& params, IfcServiceLife* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcShapeModel>(const DB& db, const LIST& params, IfcShapeModel* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcShapeRepresentation>(const DB& db, const LIST& params, IfcShapeRepresentation* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcShapeModel*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcShellBasedSurfaceModel>(const DB& db, const LIST& params, IfcShellBasedSurfaceModel* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcShellBasedSurfaceModel"); }    do { // convert the 'SbsmBoundary' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->SbsmBoundary, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcShellBasedSurfaceModel to be a `SET [1:?] OF IfcShell`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSite>(const DB& db, const LIST& params, IfcSite* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElement*>(in));
    if (params.GetSize() < 14) { throw STEP::TypeError("expected 14 arguments to IfcSite"); }    do { // convert the 'RefLatitude' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->RefLatitude, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcSite to be a `IfcCompoundPlaneAngleMeasure`")); }
    } while(0);
    do { // convert the 'RefLongitude' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->RefLongitude, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcSite to be a `IfcCompoundPlaneAngleMeasure`")); }
    } while(0);
    do { // convert the 'RefElevation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->RefElevation, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to IfcSite to be a `IfcLengthMeasure`")); }
    } while(0);
    do { // convert the 'LandTitleNumber' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->LandTitleNumber, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 12 to IfcSite to be a `IfcLabel`")); }
    } while(0);
    do { // convert the 'SiteAddress' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->SiteAddress, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 13 to IfcSite to be a `IfcPostalAddress`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSlab>(const DB& db, const LIST& params, IfcSlab* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSlabType>(const DB& db, const LIST& params, IfcSlabType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSpace>(const DB& db, const LIST& params, IfcSpace* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElement*>(in));
    if (params.GetSize() < 11) { throw STEP::TypeError("expected 11 arguments to IfcSpace"); }    do { // convert the 'InteriorOrExteriorSpace' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->InteriorOrExteriorSpace, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to IfcSpace to be a `IfcInternalOrExternalEnum`")); }
    } while(0);
    do { // convert the 'ElevationWithFlooring' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->ElevationWithFlooring, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to IfcSpace to be a `IfcLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSpaceHeaterType>(const DB& db, const LIST& params, IfcSpaceHeaterType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSpaceProgram>(const DB& db, const LIST& params, IfcSpaceProgram* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSpatialStructureElementType>(const DB& db, const LIST& params, IfcSpatialStructureElementType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSpaceType>(const DB& db, const LIST& params, IfcSpaceType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSpatialStructureElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSphere>(const DB& db, const LIST& params, IfcSphere* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcCsgPrimitive3D*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStackTerminalType>(const DB& db, const LIST& params, IfcStackTerminalType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStair>(const DB& db, const LIST& params, IfcStair* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStairFlight>(const DB& db, const LIST& params, IfcStairFlight* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStairFlightType>(const DB& db, const LIST& params, IfcStairFlightType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralActivity>(const DB& db, const LIST& params, IfcStructuralActivity* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralAction>(const DB& db, const LIST& params, IfcStructuralAction* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralActivity*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralAnalysisModel>(const DB& db, const LIST& params, IfcStructuralAnalysisModel* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSystem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralItem>(const DB& db, const LIST& params, IfcStructuralItem* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcProduct*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralConnection>(const DB& db, const LIST& params, IfcStructuralConnection* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralCurveConnection>(const DB& db, const LIST& params, IfcStructuralCurveConnection* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralConnection*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralMember>(const DB& db, const LIST& params, IfcStructuralMember* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralCurveMember>(const DB& db, const LIST& params, IfcStructuralCurveMember* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralMember*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralCurveMemberVarying>(const DB& db, const LIST& params, IfcStructuralCurveMemberVarying* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralCurveMember*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralLinearAction>(const DB& db, const LIST& params, IfcStructuralLinearAction* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralAction*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralLinearActionVarying>(const DB& db, const LIST& params, IfcStructuralLinearActionVarying* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralLinearAction*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralLoadGroup>(const DB& db, const LIST& params, IfcStructuralLoadGroup* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGroup*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralPlanarAction>(const DB& db, const LIST& params, IfcStructuralPlanarAction* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralAction*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralPlanarActionVarying>(const DB& db, const LIST& params, IfcStructuralPlanarActionVarying* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralPlanarAction*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralPointAction>(const DB& db, const LIST& params, IfcStructuralPointAction* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralAction*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralPointConnection>(const DB& db, const LIST& params, IfcStructuralPointConnection* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralConnection*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralReaction>(const DB& db, const LIST& params, IfcStructuralReaction* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralActivity*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralPointReaction>(const DB& db, const LIST& params, IfcStructuralPointReaction* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralReaction*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralResultGroup>(const DB& db, const LIST& params, IfcStructuralResultGroup* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGroup*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralSurfaceConnection>(const DB& db, const LIST& params, IfcStructuralSurfaceConnection* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralConnection*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralSurfaceMember>(const DB& db, const LIST& params, IfcStructuralSurfaceMember* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralMember*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuralSurfaceMemberVarying>(const DB& db, const LIST& params, IfcStructuralSurfaceMemberVarying* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStructuralSurfaceMember*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStructuredDimensionCallout>(const DB& db, const LIST& params, IfcStructuredDimensionCallout* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDraughtingCallout*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStyleModel>(const DB& db, const LIST& params, IfcStyleModel* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcRepresentation*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcStyledRepresentation>(const DB& db, const LIST& params, IfcStyledRepresentation* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcStyleModel*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSubContractResource>(const DB& db, const LIST& params, IfcSubContractResource* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcConstructionResource*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSubedge>(const DB& db, const LIST& params, IfcSubedge* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEdge*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSurfaceCurveSweptAreaSolid>(const DB& db, const LIST& params, IfcSurfaceCurveSweptAreaSolid* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSweptAreaSolid*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSweptSurface>(const DB& db, const LIST& params, IfcSweptSurface* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSurface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSurfaceOfLinearExtrusion>(const DB& db, const LIST& params, IfcSurfaceOfLinearExtrusion* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSweptSurface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSurfaceOfRevolution>(const DB& db, const LIST& params, IfcSurfaceOfRevolution* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSweptSurface*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSurfaceStyle>(const DB& db, const LIST& params, IfcSurfaceStyle* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcPresentationStyle*>(in));
    if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to IfcSurfaceStyle"); }    do { // convert the 'Side' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Side, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSurfaceStyle to be a `IfcSurfaceSide`")); }
    } while(0);
    do { // convert the 'Styles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Styles, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSurfaceStyle to be a `SET [1:5] OF IfcSurfaceStyleElementSelect`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSurfaceStyleShading>(const DB& db, const LIST& params, IfcSurfaceStyleShading* in)
{
    size_t base = 0;
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcSurfaceStyleShading"); }    do { // convert the 'SurfaceColour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::IFC::IfcSurfaceStyleShading,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->SurfaceColour, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSurfaceStyleShading to be a `IfcColourRgb`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSurfaceStyleRendering>(const DB& db, const LIST& params, IfcSurfaceStyleRendering* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSurfaceStyleShading*>(in));
    if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to IfcSurfaceStyleRendering"); }    do { // convert the 'Transparency' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->Transparency, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSurfaceStyleRendering to be a `IfcNormalisedRatioMeasure`")); }
    } while(0);
    do { // convert the 'DiffuseColour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->DiffuseColour, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
    } while(0);
    do { // convert the 'TransmissionColour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->TransmissionColour, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
    } while(0);
    do { // convert the 'DiffuseTransmissionColour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->DiffuseTransmissionColour, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
    } while(0);
    do { // convert the 'ReflectionColour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->ReflectionColour, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
    } while(0);
    do { // convert the 'SpecularColour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->SpecularColour, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to IfcSurfaceStyleRendering to be a `IfcColourOrFactor`")); }
    } while(0);
    do { // convert the 'SpecularHighlight' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->SpecularHighlight, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to IfcSurfaceStyleRendering to be a `IfcSpecularHighlightSelect`")); }
    } while(0);
    do { // convert the 'ReflectanceMethod' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ReflectanceMethod, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to IfcSurfaceStyleRendering to be a `IfcReflectanceMethodEnum`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSurfaceStyleWithTextures>(const DB& db, const LIST& params, IfcSurfaceStyleWithTextures* in)
{
    size_t base = 0;
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcSurfaceStyleWithTextures"); }    do { // convert the 'Textures' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Textures, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSurfaceStyleWithTextures to be a `LIST [1:?] OF IfcSurfaceTexture`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSweptDiskSolid>(const DB& db, const LIST& params, IfcSweptDiskSolid* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcSolidModel*>(in));
    if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcSweptDiskSolid"); }    do { // convert the 'Directrix' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Directrix, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcSweptDiskSolid to be a `IfcCurve`")); }
    } while(0);
    do { // convert the 'Radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Radius, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcSweptDiskSolid to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    do { // convert the 'InnerRadius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->InnerRadius, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcSweptDiskSolid to be a `IfcPositiveLengthMeasure`")); }
    } while(0);
    do { // convert the 'StartParam' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->StartParam, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcSweptDiskSolid to be a `IfcParameterValue`")); }
    } while(0);
    do { // convert the 'EndParam' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->EndParam, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcSweptDiskSolid to be a `IfcParameterValue`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSwitchingDeviceType>(const DB& db, const LIST& params, IfcSwitchingDeviceType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowControllerType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcSystemFurnitureElementType>(const DB& db, const LIST& params, IfcSystemFurnitureElementType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFurnishingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTShapeProfileDef>(const DB& db, const LIST& params, IfcTShapeProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTankType>(const DB& db, const LIST& params, IfcTankType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowStorageDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTendon>(const DB& db, const LIST& params, IfcTendon* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcReinforcingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTendonAnchor>(const DB& db, const LIST& params, IfcTendonAnchor* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcReinforcingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTextLiteral>(const DB& db, const LIST& params, IfcTextLiteral* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTextLiteralWithExtent>(const DB& db, const LIST& params, IfcTextLiteralWithExtent* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTextLiteral*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTimeSeriesSchedule>(const DB& db, const LIST& params, IfcTimeSeriesSchedule* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTopologyRepresentation>(const DB& db, const LIST& params, IfcTopologyRepresentation* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcShapeModel*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTransformerType>(const DB& db, const LIST& params, IfcTransformerType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTransportElement>(const DB& db, const LIST& params, IfcTransportElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTransportElementType>(const DB& db, const LIST& params, IfcTransportElementType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTrapeziumProfileDef>(const DB& db, const LIST& params, IfcTrapeziumProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTrimmedCurve>(const DB& db, const LIST& params, IfcTrimmedCurve* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBoundedCurve*>(in));
    if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to IfcTrimmedCurve"); }    do { // convert the 'BasisCurve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->BasisCurve, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcTrimmedCurve to be a `IfcCurve`")); }
    } while(0);
    do { // convert the 'Trim1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Trim1, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcTrimmedCurve to be a `SET [1:2] OF IfcTrimmingSelect`")); }
    } while(0);
    do { // convert the 'Trim2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Trim2, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to IfcTrimmedCurve to be a `SET [1:2] OF IfcTrimmingSelect`")); }
    } while(0);
    do { // convert the 'SenseAgreement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->SenseAgreement, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to IfcTrimmedCurve to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'MasterRepresentation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->MasterRepresentation, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to IfcTrimmedCurve to be a `IfcTrimmingPreference`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTubeBundleType>(const DB& db, const LIST& params, IfcTubeBundleType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcTwoDirectionRepeatFactor>(const DB& db, const LIST& params, IfcTwoDirectionRepeatFactor* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcOneDirectionRepeatFactor*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcUShapeProfileDef>(const DB& db, const LIST& params, IfcUShapeProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcUnitAssignment>(const DB& db, const LIST& params, IfcUnitAssignment* in)
{
    size_t base = 0;
    if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to IfcUnitAssignment"); }    do { // convert the 'Units' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Units, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcUnitAssignment to be a `SET [1:?] OF IfcUnit`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcUnitaryEquipmentType>(const DB& db, const LIST& params, IfcUnitaryEquipmentType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcEnergyConversionDeviceType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcValveType>(const DB& db, const LIST& params, IfcValveType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowControllerType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcVector>(const DB& db, const LIST& params, IfcVector* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGeometricRepresentationItem*>(in));
    if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to IfcVector"); }    do { // convert the 'Orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Orientation, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to IfcVector to be a `IfcDirection`")); }
    } while(0);
    do { // convert the 'Magnitude' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->Magnitude, arg, db ); break; }
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to IfcVector to be a `IfcLengthMeasure`")); }
    } while(0);
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcVertex>(const DB& db, const LIST& params, IfcVertex* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTopologicalRepresentationItem*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcVertexLoop>(const DB& db, const LIST& params, IfcVertexLoop* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcLoop*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcVertexPoint>(const DB& db, const LIST& params, IfcVertexPoint* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcVertex*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcVibrationIsolatorType>(const DB& db, const LIST& params, IfcVibrationIsolatorType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcDiscreteAccessoryType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcVirtualElement>(const DB& db, const LIST& params, IfcVirtualElement* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcWall>(const DB& db, const LIST& params, IfcWall* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcWallStandardCase>(const DB& db, const LIST& params, IfcWallStandardCase* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcWall*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcWallType>(const DB& db, const LIST& params, IfcWallType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElementType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcWasteTerminalType>(const DB& db, const LIST& params, IfcWasteTerminalType* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcFlowTerminalType*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcWindow>(const DB& db, const LIST& params, IfcWindow* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcBuildingElement*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcWindowStyle>(const DB& db, const LIST& params, IfcWindowStyle* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcTypeProduct*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcWorkControl>(const DB& db, const LIST& params, IfcWorkControl* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcWorkPlan>(const DB& db, const LIST& params, IfcWorkPlan* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcWorkControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcWorkSchedule>(const DB& db, const LIST& params, IfcWorkSchedule* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcWorkControl*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcZShapeProfileDef>(const DB& db, const LIST& params, IfcZShapeProfileDef* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcParameterizedProfileDef*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<IfcZone>(const DB& db, const LIST& params, IfcZone* in)
{
    size_t base = GenericFill(db,params,static_cast<IfcGroup*>(in));
// this data structure is not used yet, so there is no code generated to fill its members
    return base;
}

} // ! STEP
} // ! Assimp

#endif
